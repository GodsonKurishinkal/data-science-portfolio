<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Truck Loading Simulation - Delivery Planning System</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            overflow: hidden;
        }
        
        #container {
            display: flex;
            height: 100vh;
        }
        
        #sidebar {
            width: 350px;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #canvas-container {
            flex: 1;
            position: relative;
        }
        
        h1 {
            font-size: 1.5rem;
            margin-bottom: 10px;
            color: #4ecdc4;
        }
        
        h2 {
            font-size: 1.1rem;
            margin: 20px 0 10px;
            color: #ff6b6b;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 5px;
        }
        
        .subtitle {
            font-size: 0.85rem;
            color: #aaa;
            margin-bottom: 20px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9rem;
            color: #ccc;
        }
        
        input[type="number"], select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 0.9rem;
        }
        
        input[type="number"]:focus, select:focus {
            outline: none;
            border-color: #4ecdc4;
        }
        
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s ease;
            margin: 5px 5px 5px 0;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #4ecdc4 0%, #44a08d 100%);
            color: #fff;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(78, 205, 196, 0.4);
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a5a 100%);
            color: #fff;
        }
        
        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255, 107, 107, 0.4);
        }
        
        #stats {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }
        
        .stat-label {
            color: #aaa;
        }
        
        .stat-value {
            color: #4ecdc4;
            font-weight: 600;
        }
        
        #box-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }
        
        .box-item {
            display: flex;
            align-items: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            margin-bottom: 5px;
            font-size: 0.85rem;
        }
        
        .box-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            margin-right: 10px;
        }
        
        .box-info {
            flex: 1;
        }
        
        .box-dims {
            color: #aaa;
            font-size: 0.8rem;
        }
        
        #info-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border-radius: 8px;
            font-size: 0.9rem;
        }
        
        #loading-status {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 30px;
            border-radius: 20px;
            font-size: 0.9rem;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            margin-top: 10px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ecdc4, #44a08d);
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        
        .dimension-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
        }
        
        .dimension-inputs input {
            text-align: center;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
        }
        
        .truck-type-select {
            margin-bottom: 15px;
        }
        
        .door-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .door-controls button {
            flex: 1;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="sidebar">
            <h1>üöö 3D Truck Loading</h1>
            <p class="subtitle">Interactive Bin Packing Simulation</p>
            
            <h2>üöõ Select Truck Type</h2>
            <div class="truck-type-select">
                <select id="truck-type" onchange="changeTruckType()">
                    <option value="small_van">Small Van (300√ó150√ó180 cm)</option>
                    <option value="medium_truck">Medium Truck (450√ó200√ó220 cm)</option>
                    <option value="large_truck" selected>Large Truck (600√ó250√ó270 cm)</option>
                    <option value="semi_trailer">Semi Trailer (1350√ó250√ó280 cm)</option>
                </select>
            </div>
            <div class="door-controls">
                <button class="btn-secondary" onclick="toggleDoors()">üö™ Toggle Doors</button>
            </div>
            
            <h2>üì¶ Add Package</h2>
            <div class="dimension-inputs">
                <div class="control-group">
                    <label>Length</label>
                    <input type="number" id="box-length" value="50" min="10" max="200">
                </div>
                <div class="control-group">
                    <label>Width</label>
                    <input type="number" id="box-width" value="40" min="10" max="200">
                </div>
                <div class="control-group">
                    <label>Height</label>
                    <input type="number" id="box-height" value="30" min="10" max="200">
                </div>
            </div>
            <div class="control-group">
                <label>Weight (kg)</label>
                <input type="number" id="box-weight" value="10" min="1" max="500">
            </div>
            <div class="control-group">
                <label>Delivery Sequence (1 = first)</label>
                <input type="number" id="box-sequence" value="1" min="1" max="100">
            </div>
            <div class="control-group checkbox-group">
                <input type="checkbox" id="box-fragile">
                <label for="box-fragile">Fragile Item ‚ö†Ô∏è</label>
            </div>
            <button class="btn-primary" onclick="addBox()">‚ûï Add Package</button>
            <button class="btn-secondary" onclick="addRandomBoxes()">üé≤ Add 10 Random</button>
            
            <h2>üéÆ Controls</h2>
            <button class="btn-primary" onclick="runPacking()">‚ñ∂Ô∏è Run Packing</button>
            <button class="btn-primary" onclick="animatePacking()">üé¨ Animate Load</button>
            <button class="btn-secondary" onclick="resetCamera()">üé• Reset View</button>
            <button class="btn-danger" onclick="clearAll()">üóëÔ∏è Clear All</button>
            
            <h2>üìä Statistics</h2>
            <div id="stats">
                <div class="stat-row">
                    <span class="stat-label">Truck Type:</span>
                    <span class="stat-value" id="stat-truck">Large Truck</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Cargo Space:</span>
                    <span class="stat-value" id="stat-space">600√ó250√ó270 cm</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Boxes Added:</span>
                    <span class="stat-value" id="stat-boxes">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Boxes Packed:</span>
                    <span class="stat-value" id="stat-packed">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Volume Used:</span>
                    <span class="stat-value" id="stat-volume">0%</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Weight Used:</span>
                    <span class="stat-value" id="stat-weight">0 / 5000 kg</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
                </div>
            </div>
            
            <h2>üìã Package List</h2>
            <div id="box-list"></div>
        </div>
        
        <div id="canvas-container">
            <div id="info-overlay">
                <strong>Controls:</strong><br>
                üñ±Ô∏è Left click + drag: Rotate<br>
                üñ±Ô∏è Right click + drag: Pan<br>
                üñ±Ô∏è Scroll: Zoom
            </div>
            <div id="loading-status">Ready to load</div>
        </div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let truckGroup;
        let cargoFloor;
        let leftDoor, rightDoor;
        let doorsOpen = true;
        let boxes = [];
        let packedMeshes = [];
        let boxIdCounter = 0;
        
        // Truck configurations
        const TRUCK_CONFIGS = {
            small_van: {
                name: 'Small Van',
                cargo: { length: 300, width: 150, height: 180 },
                maxWeight: 1000,
                cabLength: 120,
                wheelRadius: 35,
                color: 0x2196F3,
                isVan: true
            },
            medium_truck: {
                name: 'Medium Truck',
                cargo: { length: 450, width: 200, height: 220 },
                maxWeight: 3000,
                cabLength: 150,
                wheelRadius: 45,
                color: 0xFF9800
            },
            large_truck: {
                name: 'Large Truck',
                cargo: { length: 600, width: 250, height: 270 },
                maxWeight: 5000,
                cabLength: 180,
                wheelRadius: 50,
                color: 0xE53935
            },
            semi_trailer: {
                name: 'Semi Trailer',
                cargo: { length: 1350, width: 250, height: 280 },
                maxWeight: 25000,
                cabLength: 200,
                wheelRadius: 55,
                color: 0x1565C0,
                isTrailer: true
            }
        };
        
        let currentTruckType = 'large_truck';
        let truckDims = { ...TRUCK_CONFIGS.large_truck.cargo };
        let maxWeight = TRUCK_CONFIGS.large_truck.maxWeight;
        
        const SCALE = 0.01;
        
        // Color palette for boxes (cardboard colors)
        const BOX_COLORS = [
            0x8D6E63, 0xA1887F, 0xBCAAA4, 0x795548,
            0xD7CCC8, 0x6D4C41, 0x5D4037, 0x4E342E,
            0xFFCC80, 0xFFE0B2, 0xFFB74D, 0xFFA726
        ];
        
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue
            
            // Add fog for depth
            scene.fog = new THREE.Fog(0x87CEEB, 20, 100);
            
            const container = document.getElementById('canvas-container');
            camera = new THREE.PerspectiveCamera(
                50,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            camera.position.set(12, 6, 12);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 50;
            controls.maxPolarAngle = Math.PI / 2;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
            sunLight.position.set(20, 30, 20);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 100;
            sunLight.shadow.camera.left = -20;
            sunLight.shadow.camera.right = 20;
            sunLight.shadow.camera.top = 20;
            sunLight.shadow.camera.bottom = -20;
            scene.add(sunLight);
            
            // Ground
            createGround();
            
            // Create truck
            createTruck();
            
            window.addEventListener('resize', onWindowResize);
            animate();
        }
        
        function createGround() {
            // Asphalt ground
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x3a3a3a,
                roughness: 0.9,
                metalness: 0.1
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.01;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Road markings
            const lineGeometry = new THREE.PlaneGeometry(0.15, 50);
            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
            
            for (let i = -2; i <= 2; i++) {
                const line = new THREE.Mesh(lineGeometry, lineMaterial);
                line.rotation.x = -Math.PI / 2;
                line.position.set(i * 3, 0.01, 0);
                scene.add(line);
            }
            
            // Warehouse floor area
            const warehouseGeometry = new THREE.PlaneGeometry(15, 20);
            const warehouseMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x606060,
                roughness: 0.7
            });
            const warehouse = new THREE.Mesh(warehouseGeometry, warehouseMaterial);
            warehouse.rotation.x = -Math.PI / 2;
            warehouse.position.set(-12, 0.02, 0);
            warehouse.receiveShadow = true;
            scene.add(warehouse);
        }
        
        function createTruck() {
            if (truckGroup) {
                scene.remove(truckGroup);
            }
            
            truckGroup = new THREE.Group();
            const config = TRUCK_CONFIGS[currentTruckType];
            
            const cargoL = truckDims.length * SCALE;
            const cargoW = truckDims.width * SCALE;
            const cargoH = truckDims.height * SCALE;
            const cabL = config.cabLength * SCALE;
            const wheelR = config.wheelRadius * SCALE;
            const floorHeight = wheelR * 1.3;
            
            // Materials
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: config.color,
                roughness: 0.3,
                metalness: 0.6
            });
            
            const whiteMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xF5F5F5,
                roughness: 0.4,
                metalness: 0.2
            });
            
            const darkMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a1a,
                roughness: 0.8
            });
            
            const glassMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x87CEEB,
                transparent: true,
                opacity: 0.6,
                roughness: 0.1,
                metalness: 0.9
            });
            
            const cargoMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xEEEEEE,
                roughness: 0.5,
                metalness: 0.3
            });
            
            // === CARGO BOX ===
            const cargoGroup = new THREE.Group();
            
            // Cargo floor
            const floorThickness = 0.08;
            const floorGeo = new THREE.BoxGeometry(cargoL, floorThickness, cargoW);
            cargoFloor = new THREE.Mesh(floorGeo, darkMaterial);
            cargoFloor.position.set(cargoL/2, floorHeight, cargoW/2);
            cargoFloor.castShadow = true;
            cargoFloor.receiveShadow = true;
            cargoGroup.add(cargoFloor);
            
            // Cargo walls
            const wallThickness = 0.05;
            
            // Left wall
            const leftWallGeo = new THREE.BoxGeometry(cargoL, cargoH, wallThickness);
            const leftWall = new THREE.Mesh(leftWallGeo, cargoMaterial);
            leftWall.position.set(cargoL/2, floorHeight + cargoH/2, wallThickness/2);
            leftWall.castShadow = true;
            cargoGroup.add(leftWall);
            
            // Right wall
            const rightWall = new THREE.Mesh(leftWallGeo, cargoMaterial);
            rightWall.position.set(cargoL/2, floorHeight + cargoH/2, cargoW - wallThickness/2);
            rightWall.castShadow = true;
            cargoGroup.add(rightWall);
            
            // Front wall (behind cab)
            const frontWallGeo = new THREE.BoxGeometry(wallThickness, cargoH, cargoW);
            const frontWall = new THREE.Mesh(frontWallGeo, cargoMaterial);
            frontWall.position.set(cargoL - wallThickness/2, floorHeight + cargoH/2, cargoW/2);
            frontWall.castShadow = true;
            cargoGroup.add(frontWall);
            
            // Roof
            const roofGeo = new THREE.BoxGeometry(cargoL, wallThickness, cargoW);
            const roof = new THREE.Mesh(roofGeo, cargoMaterial);
            roof.position.set(cargoL/2, floorHeight + cargoH, cargoW/2);
            roof.castShadow = true;
            cargoGroup.add(roof);
            
            // === REAR DOORS ===
            // Doors swing outward from hinges at the outer edges of the truck
            const doorWidth = (cargoW - wallThickness * 2) / 2;
            const doorGeo = new THREE.BoxGeometry(wallThickness * 2, cargoH * 0.95, doorWidth);
            
            // Left door - hinge is at z=0 (left edge of truck)
            leftDoor = new THREE.Group();
            const leftDoorMesh = new THREE.Mesh(doorGeo, cargoMaterial);
            // Position door mesh so pivot point is at the hinge (outer edge)
            leftDoorMesh.position.set(wallThickness, 0, doorWidth/2);
            leftDoor.add(leftDoorMesh);
            
            // Door handle left (on the inner edge, near center of truck)
            const handleGeo = new THREE.BoxGeometry(0.08, 0.3, 0.05);
            const leftHandle = new THREE.Mesh(handleGeo, darkMaterial);
            leftHandle.position.set(wallThickness * 2 + 0.02, 0, doorWidth - 0.15);
            leftDoor.add(leftHandle);
            
            // Position left door group at the hinge point (left outer edge at rear)
            leftDoor.position.set(0, floorHeight + cargoH/2, 0);
            cargoGroup.add(leftDoor);
            
            // Right door - hinge is at z=cargoW (right edge of truck)
            rightDoor = new THREE.Group();
            const rightDoorMesh = new THREE.Mesh(doorGeo, cargoMaterial);
            // Position door mesh so pivot point is at the hinge (outer edge)
            rightDoorMesh.position.set(wallThickness, 0, -doorWidth/2);
            rightDoor.add(rightDoorMesh);
            
            // Door handle right (on the inner edge, near center of truck)
            const rightHandle = new THREE.Mesh(handleGeo, darkMaterial);
            rightHandle.position.set(wallThickness * 2 + 0.02, 0, -doorWidth + 0.15);
            rightDoor.add(rightHandle);
            
            // Position right door group at the hinge point (right outer edge at rear)
            rightDoor.position.set(0, floorHeight + cargoH/2, cargoW);
            cargoGroup.add(rightDoor);
            
            // Open doors by default - swing outward from hinges
            leftDoor.rotation.y = Math.PI / 2;  // Left door opens to the left
            rightDoor.rotation.y = -Math.PI / 2; // Right door opens to the right
            
            // === CAB ===
            const cabGroup = new THREE.Group();
            const cabHeight = cargoH * 0.85;
            const cabWidth = cargoW * 0.95;
            
            // Cab body
            const cabGeo = new THREE.BoxGeometry(cabL, cabHeight, cabWidth);
            const cab = new THREE.Mesh(cabGeo, bodyMaterial);
            cab.position.set(cargoL + cabL/2 + 0.1, floorHeight + cabHeight/2, cargoW/2);
            cab.castShadow = true;
            cabGroup.add(cab);
            
            // Cab roof (slightly curved effect with box)
            const cabRoofGeo = new THREE.BoxGeometry(cabL * 0.9, 0.1, cabWidth * 0.9);
            const cabRoof = new THREE.Mesh(cabRoofGeo, bodyMaterial);
            cabRoof.position.set(cargoL + cabL/2 + 0.1, floorHeight + cabHeight + 0.05, cargoW/2);
            cabRoof.castShadow = true;
            cabGroup.add(cabRoof);
            
            // Windshield
            const windshieldGeo = new THREE.BoxGeometry(0.05, cabHeight * 0.5, cabWidth * 0.8);
            const windshield = new THREE.Mesh(windshieldGeo, glassMaterial);
            windshield.position.set(cargoL + cabL + 0.1, floorHeight + cabHeight * 0.65, cargoW/2);
            cabGroup.add(windshield);
            
            // Side windows
            const sideWindowGeo = new THREE.BoxGeometry(cabL * 0.4, cabHeight * 0.35, 0.05);
            const leftWindow = new THREE.Mesh(sideWindowGeo, glassMaterial);
            leftWindow.position.set(cargoL + cabL * 0.7, floorHeight + cabHeight * 0.6, cargoW/2 - cabWidth/2);
            cabGroup.add(leftWindow);
            
            const rightWindow = new THREE.Mesh(sideWindowGeo, glassMaterial);
            rightWindow.position.set(cargoL + cabL * 0.7, floorHeight + cabHeight * 0.6, cargoW/2 + cabWidth/2);
            cabGroup.add(rightWindow);
            
            // Headlights
            const headlightGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.05, 16);
            const headlightMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFFFCC,
                emissive: 0xFFFF00,
                emissiveIntensity: 0.3
            });
            
            const leftHeadlight = new THREE.Mesh(headlightGeo, headlightMaterial);
            leftHeadlight.rotation.z = Math.PI / 2;
            leftHeadlight.position.set(cargoL + cabL + 0.12, floorHeight + cabHeight * 0.3, cargoW/2 - cabWidth * 0.35);
            cabGroup.add(leftHeadlight);
            
            const rightHeadlight = new THREE.Mesh(headlightGeo, headlightMaterial);
            rightHeadlight.rotation.z = Math.PI / 2;
            rightHeadlight.position.set(cargoL + cabL + 0.12, floorHeight + cabHeight * 0.3, cargoW/2 + cabWidth * 0.35);
            cabGroup.add(rightHeadlight);
            
            // Grille
            const grilleGeo = new THREE.BoxGeometry(0.05, cabHeight * 0.25, cabWidth * 0.5);
            const grille = new THREE.Mesh(grilleGeo, darkMaterial);
            grille.position.set(cargoL + cabL + 0.1, floorHeight + cabHeight * 0.35, cargoW/2);
            cabGroup.add(grille);
            
            // Bumper
            const bumperGeo = new THREE.BoxGeometry(0.15, 0.15, cabWidth);
            const bumper = new THREE.Mesh(bumperGeo, darkMaterial);
            bumper.position.set(cargoL + cabL + 0.15, floorHeight * 0.5, cargoW/2);
            bumper.castShadow = true;
            cabGroup.add(bumper);
            
            // Side mirrors
            const mirrorGeo = new THREE.BoxGeometry(0.1, 0.15, 0.08);
            const leftMirror = new THREE.Mesh(mirrorGeo, darkMaterial);
            leftMirror.position.set(cargoL + cabL * 0.9, floorHeight + cabHeight * 0.7, cargoW/2 - cabWidth/2 - 0.15);
            cabGroup.add(leftMirror);
            
            const rightMirror = new THREE.Mesh(mirrorGeo, darkMaterial);
            rightMirror.position.set(cargoL + cabL * 0.9, floorHeight + cabHeight * 0.7, cargoW/2 + cabWidth/2 + 0.15);
            cabGroup.add(rightMirror);
            
            // === WHEELS ===
            const wheelGroup = new THREE.Group();
            
            function createWheel(x, z) {
                const wheel = new THREE.Group();
                
                // Tire
                const tireGeo = new THREE.CylinderGeometry(wheelR, wheelR, wheelR * 0.4, 24);
                const tire = new THREE.Mesh(tireGeo, new THREE.MeshStandardMaterial({ 
                    color: 0x1a1a1a,
                    roughness: 0.9
                }));
                tire.rotation.x = Math.PI / 2;
                tire.castShadow = true;
                wheel.add(tire);
                
                // Hubcap
                const hubGeo = new THREE.CylinderGeometry(wheelR * 0.5, wheelR * 0.5, wheelR * 0.42, 16);
                const hub = new THREE.Mesh(hubGeo, new THREE.MeshStandardMaterial({ 
                    color: 0xCCCCCC,
                    metalness: 0.8,
                    roughness: 0.2
                }));
                hub.rotation.x = Math.PI / 2;
                wheel.add(hub);
                
                wheel.position.set(x, wheelR, z);
                return wheel;
            }
            
            // Front wheels
            wheelGroup.add(createWheel(cargoL + cabL * 0.7, cargoW/2 - cabWidth/2 - wheelR * 0.2));
            wheelGroup.add(createWheel(cargoL + cabL * 0.7, cargoW/2 + cabWidth/2 + wheelR * 0.2));
            
            // Rear wheels (dual for larger trucks)
            const rearWheelX = cargoL * 0.25;
            wheelGroup.add(createWheel(rearWheelX, cargoW/2 - cargoW/2 - wheelR * 0.2));
            wheelGroup.add(createWheel(rearWheelX, cargoW/2 + cargoW/2 + wheelR * 0.2));
            
            if (currentTruckType === 'large_truck' || currentTruckType === 'semi_trailer') {
                // Second set of rear wheels
                wheelGroup.add(createWheel(rearWheelX - wheelR * 1.2, cargoW/2 - cargoW/2 - wheelR * 0.2));
                wheelGroup.add(createWheel(rearWheelX - wheelR * 1.2, cargoW/2 + cargoW/2 + wheelR * 0.2));
            }
            
            if (currentTruckType === 'semi_trailer') {
                // Additional trailer wheels
                const midWheelX = cargoL * 0.6;
                wheelGroup.add(createWheel(midWheelX, cargoW/2 - cargoW/2 - wheelR * 0.2));
                wheelGroup.add(createWheel(midWheelX, cargoW/2 + cargoW/2 + wheelR * 0.2));
            }
            
            // === CHASSIS ===
            const chassisGeo = new THREE.BoxGeometry(cargoL + cabL + 0.2, 0.15, cargoW * 0.3);
            const chassis = new THREE.Mesh(chassisGeo, darkMaterial);
            chassis.position.set((cargoL + cabL) / 2, wheelR * 0.8, cargoW/2);
            chassis.castShadow = true;
            
            // === TAIL LIGHTS ===
            const tailLightGeo = new THREE.BoxGeometry(0.05, 0.15, 0.1);
            const tailLightMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFF0000,
                emissive: 0x330000,
                emissiveIntensity: 0.5
            });
            
            const leftTailLight = new THREE.Mesh(tailLightGeo, tailLightMaterial);
            leftTailLight.position.set(-0.03, floorHeight + 0.2, wallThickness + 0.1);
            cargoGroup.add(leftTailLight);
            
            const rightTailLight = new THREE.Mesh(tailLightGeo, tailLightMaterial);
            rightTailLight.position.set(-0.03, floorHeight + 0.2, cargoW - wallThickness - 0.1);
            cargoGroup.add(rightTailLight);
            
            // Assemble truck
            truckGroup.add(cargoGroup);
            truckGroup.add(cabGroup);
            truckGroup.add(wheelGroup);
            truckGroup.add(chassis);
            
            // Center the truck
            truckGroup.position.set(-cargoL/2, 0, -cargoW/2);
            
            scene.add(truckGroup);
            
            updateStats();
        }
        
        function toggleDoors() {
            doorsOpen = !doorsOpen;
            
            // Doors swing from hinges at outer edges
            // Open: left door rotates +90¬∞ (opens left), right door rotates -90¬∞ (opens right)
            // Closed: both doors at 0¬∞
            const leftTargetAngle = doorsOpen ? Math.PI / 2 : 0;
            const rightTargetAngle = doorsOpen ? -Math.PI / 2 : 0;
            
            // Animate doors
            const duration = 500;
            const startTime = Date.now();
            const startLeftAngle = leftDoor.rotation.y;
            const startRightAngle = rightDoor.rotation.y;
            
            function animateDoors() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = 1 - Math.pow(1 - progress, 3);
                
                leftDoor.rotation.y = startLeftAngle + (leftTargetAngle - startLeftAngle) * eased;
                rightDoor.rotation.y = startRightAngle + (rightTargetAngle - startRightAngle) * eased;
                
                if (progress < 1) {
                    requestAnimationFrame(animateDoors);
                }
            }
            
            animateDoors();
            updateStatus(doorsOpen ? 'Doors opened' : 'Doors closed');
        }
        
        function changeTruckType() {
            currentTruckType = document.getElementById('truck-type').value;
            const config = TRUCK_CONFIGS[currentTruckType];
            truckDims = { ...config.cargo };
            maxWeight = config.maxWeight;
            
            clearPackedBoxes();
            createTruck();
            resetCamera();
            
            document.getElementById('stat-truck').textContent = config.name;
            document.getElementById('stat-space').textContent = 
                `${truckDims.length}√ó${truckDims.width}√ó${truckDims.height} cm`;
            
            updateStats();
            updateStatus(`Switched to ${config.name}`);
        }
        
        function addBox() {
            const box = {
                id: ++boxIdCounter,
                length: parseInt(document.getElementById('box-length').value),
                width: parseInt(document.getElementById('box-width').value),
                height: parseInt(document.getElementById('box-height').value),
                weight: parseInt(document.getElementById('box-weight').value),
                sequence: parseInt(document.getElementById('box-sequence').value),
                fragile: document.getElementById('box-fragile').checked,
                color: BOX_COLORS[boxIdCounter % BOX_COLORS.length],
                packed: false,
                position: null
            };
            
            boxes.push(box);
            updateBoxList();
            updateStats();
            updateStatus(`Added package #${box.id}`);
        }
        
        function addRandomBoxes() {
            for (let i = 0; i < 10; i++) {
                const box = {
                    id: ++boxIdCounter,
                    length: Math.floor(Math.random() * 60) + 20,
                    width: Math.floor(Math.random() * 50) + 20,
                    height: Math.floor(Math.random() * 40) + 15,
                    weight: Math.floor(Math.random() * 30) + 5,
                    sequence: Math.floor(Math.random() * 10) + 1,
                    fragile: Math.random() > 0.85,
                    color: BOX_COLORS[boxIdCounter % BOX_COLORS.length],
                    packed: false,
                    position: null
                };
                boxes.push(box);
            }
            updateBoxList();
            updateStats();
            updateStatus(`Added 10 packages`);
        }
        
        // Human-realistic packing: Load from front (cab side) to back (doors)
        // Workers enter through rear doors, walk to the front, and start loading there
        // Fill a section (floor first, then stack), before moving toward the doors
        function runPacking() {
            clearPackedBoxes();
            
            if (boxes.length === 0) {
                updateStatus('No packages to load!');
                return;
            }
            
            // Sort by delivery sequence (last delivery first = goes deepest in truck)
            // Then by size for efficient stacking
            const sortedBoxes = [...boxes].sort((a, b) => {
                // Higher sequence number = delivered later = loaded first (goes to front)
                if (b.sequence !== a.sequence) return b.sequence - a.sequence;
                // Larger/heavier boxes first for stability
                return (b.length * b.width * b.height) - (a.length * a.width * a.height);
            });
            
            const packedBoxes = [];
            
            // Human loading zones - divide truck into sections from front to back
            const zoneDepth = 100; // 100cm zones (about arm's reach)
            const numZones = Math.ceil(truckDims.length / zoneDepth);
            
            for (const box of sortedBoxes) {
                let bestPoint = null;
                let bestRotation = false;
                let bestScore = Infinity;
                
                const rotations = [
                    { l: box.length, w: box.width, rotated: false },
                    { l: box.width, w: box.length, rotated: true }
                ];
                
                // Try to place in zones from FRONT (cab) to BACK (doors)
                for (let zone = numZones - 1; zone >= 0; zone--) {
                    const zoneStartX = zone * zoneDepth;
                    const zoneEndX = Math.min((zone + 1) * zoneDepth, truckDims.length);
                    
                    // Generate candidate positions based on existing boxes
                    const candidates = generateStackingPositions(packedBoxes, zoneStartX, zoneEndX);
                    
                    for (const pos of candidates) {
                        for (const rot of rotations) {
                            if (canPlaceBox(pos, rot.l, rot.w, box.height, packedBoxes)) {
                                // Score: prioritize front (high x), then lower positions, then left
                                // This fills each zone floor first, stacks, then moves to next zone
                                const score = -pos.x * 10000 + pos.y * 10 + pos.z * 0.1;
                                if (score < bestScore) {
                                    bestScore = score;
                                    bestPoint = { ...pos };
                                    bestRotation = rot.rotated;
                                }
                            }
                        }
                    }
                    
                    // If found a spot in this zone, don't check zones closer to doors
                    if (bestPoint) break;
                }
                
                if (bestPoint) {
                    const l = bestRotation ? box.width : box.length;
                    const w = bestRotation ? box.length : box.width;
                    
                    box.packed = true;
                    box.position = { ...bestPoint };
                    box.packedDims = { length: l, width: w, height: box.height };
                    box.rotated = bestRotation;
                    packedBoxes.push(box);
                }
            }
            
            for (const box of packedBoxes) {
                createBoxMesh(box);
            }
            
            updateStats();
            updateBoxList();
            updateStatus(`Loaded ${packedBoxes.length}/${boxes.length} packages (front-to-back)`);
        }
        
        // Generate stacking positions - floor grid + on top of existing boxes
        function generateStackingPositions(packedBoxes, zoneStartX, zoneEndX) {
            const positions = [];
            const gridStep = 20; // 20cm grid for floor positions
            
            // Floor positions within the zone
            for (let x = zoneEndX - gridStep; x >= zoneStartX; x -= gridStep) {
                for (let z = 0; z < truckDims.width; z += gridStep) {
                    positions.push({ x, y: 0, z });
                }
            }
            
            // Stacking positions on top of existing boxes
            for (const packed of packedBoxes) {
                const topY = packed.position.y + packed.packedDims.height;
                
                // Only stack if there's room above
                if (topY < truckDims.height - 10) {
                    // Position directly on top
                    positions.push({ 
                        x: packed.position.x, 
                        y: topY, 
                        z: packed.position.z 
                    });
                    
                    // Also try corners of the box top
                    if (packed.position.x + packed.packedDims.length <= truckDims.length) {
                        positions.push({
                            x: packed.position.x + packed.packedDims.length / 2,
                            y: topY,
                            z: packed.position.z
                        });
                    }
                    if (packed.position.z + packed.packedDims.width <= truckDims.width) {
                        positions.push({
                            x: packed.position.x,
                            y: topY,
                            z: packed.position.z + packed.packedDims.width / 2
                        });
                    }
                }
            }
            
            // Remove duplicates and positions outside zone
            const unique = [];
            const seen = new Set();
            for (const pos of positions) {
                if (pos.x >= zoneStartX && pos.x < zoneEndX) {
                    const key = `${Math.round(pos.x)},${Math.round(pos.y)},${Math.round(pos.z)}`;
                    if (!seen.has(key)) {
                        seen.add(key);
                        unique.push(pos);
                    }
                }
            }
            
            // Sort: lower Y first (fill floor), then higher X (front of truck)
            unique.sort((a, b) => {
                if (a.y !== b.y) return a.y - b.y;
                return b.x - a.x;
            });
            
            return unique;
        }
        
        function canPlaceBox(position, length, width, height, packedBoxes) {
            if (position.x + length > truckDims.length) return false;
            if (position.y + height > truckDims.height) return false;
            if (position.z + width > truckDims.width) return false;
            if (position.x < 0 || position.z < 0) return false;
            
            // Check collision with existing boxes
            for (const packed of packedBoxes) {
                if (boxesIntersect(
                    position.x, position.y, position.z, length, height, width,
                    packed.position.x, packed.position.y, packed.position.z,
                    packed.packedDims.length, packed.packedDims.height, packed.packedDims.width
                )) {
                    return false;
                }
            }
            
            // Check support - must be on floor or supported by boxes below
            if (position.y > 0.1) {
                let supportArea = 0;
                const boxArea = length * width;
                
                for (const packed of packedBoxes) {
                    const packedTop = packed.position.y + packed.packedDims.height;
                    // Check if this box is directly below (within 2cm tolerance)
                    if (Math.abs(packedTop - position.y) < 2) {
                        const overlapX = Math.max(0, 
                            Math.min(position.x + length, packed.position.x + packed.packedDims.length) -
                            Math.max(position.x, packed.position.x)
                        );
                        const overlapZ = Math.max(0,
                            Math.min(position.z + width, packed.position.z + packed.packedDims.width) -
                            Math.max(position.z, packed.position.z)
                        );
                        supportArea += overlapX * overlapZ;
                    }
                }
                
                // Need at least 40% support for stability
                if (supportArea / boxArea < 0.4) return false;
            }
            
            return true;
        }
        
        function boxesIntersect(x1, y1, z1, l1, h1, w1, x2, y2, z2, l2, h2, w2) {
            return !(x1 + l1 <= x2 || x2 + l2 <= x1 ||
                    y1 + h1 <= y2 || y2 + h2 <= y1 ||
                    z1 + w1 <= z2 || z2 + w2 <= z1);
        }
        
        function isPointInsideBox(point, packedBoxes) {
            for (const box of packedBoxes) {
                if (point.x >= box.position.x && point.x < box.position.x + box.packedDims.length &&
                    point.y >= box.position.y && point.y < box.position.y + box.packedDims.height &&
                    point.z >= box.position.z && point.z < box.position.z + box.packedDims.width) {
                    return true;
                }
            }
            return false;
        }
        
        function createBoxMesh(box) {
            const config = TRUCK_CONFIGS[currentTruckType];
            const wheelR = config.wheelRadius * SCALE;
            const floorHeight = wheelR * 1.3 + 0.04;
            
            const l = box.packedDims.length * SCALE;
            const h = box.packedDims.height * SCALE;
            const w = box.packedDims.width * SCALE;
            
            // Cardboard box material
            const boxMaterial = new THREE.MeshStandardMaterial({
                color: box.color,
                roughness: 0.8,
                metalness: 0.0
            });
            
            const geometry = new THREE.BoxGeometry(l * 0.98, h * 0.98, w * 0.98);
            const mesh = new THREE.Mesh(geometry, boxMaterial);
            
            // Position relative to cargo floor
            const cargoL = truckDims.length * SCALE;
            const cargoW = truckDims.width * SCALE;
            
            mesh.position.set(
                box.position.x * SCALE + l/2 - cargoL/2,
                floorHeight + box.position.y * SCALE + h/2,
                box.position.z * SCALE + w/2 - cargoW/2
            );
            
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            // Add edges for cardboard look
            const edges = new THREE.EdgesGeometry(geometry);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x5D4037, linewidth: 1 });
            const wireframe = new THREE.LineSegments(edges, lineMaterial);
            mesh.add(wireframe);
            
            // Add tape effect on top
            const tapeGeo = new THREE.BoxGeometry(l * 0.15, 0.01, w * 0.98);
            const tapeMaterial = new THREE.MeshStandardMaterial({ color: 0xD2B48C });
            const tape = new THREE.Mesh(tapeGeo, tapeMaterial);
            tape.position.y = h/2;
            mesh.add(tape);
            
            // Fragile sticker
            if (box.fragile) {
                const stickerGeo = new THREE.PlaneGeometry(l * 0.4, h * 0.3);
                const stickerMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xFF0000,
                    side: THREE.DoubleSide
                });
                const sticker = new THREE.Mesh(stickerGeo, stickerMaterial);
                sticker.rotation.y = Math.PI / 2;
                sticker.position.x = l/2 + 0.001;
                mesh.add(sticker);
            }
            
            scene.add(mesh);
            packedMeshes.push(mesh);
        }
        
        // Human-realistic animated loading
        // Workers enter through rear doors, carry box to the front, place it
        // Fill front section first (floor, then stack), move toward doors
        async function animatePacking() {
            clearPackedBoxes();
            
            if (boxes.length === 0) {
                updateStatus('No packages to load!');
                return;
            }
            
            // Open doors if closed
            if (!doorsOpen) {
                toggleDoors();
                await sleep(600);
            }
            
            boxes.forEach(b => { b.packed = false; b.position = null; });
            
            // Sort: last delivery first (goes deepest), then by size
            const sortedBoxes = [...boxes].sort((a, b) => {
                if (b.sequence !== a.sequence) return b.sequence - a.sequence;
                return (b.length * b.width * b.height) - (a.length * a.width * a.height);
            });
            
            const packedBoxes = [];
            
            // Human loading zones - divide truck into sections from front to back
            const zoneDepth = 100;
            const numZones = Math.ceil(truckDims.length / zoneDepth);
            
            for (let i = 0; i < sortedBoxes.length; i++) {
                const box = sortedBoxes[i];
                updateStatus(`Worker loading package ${i + 1}/${sortedBoxes.length}...`);
                
                let bestPoint = null;
                let bestRotation = false;
                let bestScore = Infinity;
                
                const rotations = [
                    { l: box.length, w: box.width, rotated: false },
                    { l: box.width, w: box.length, rotated: true }
                ];
                
                // Try zones from FRONT (cab) to BACK (doors)
                for (let zone = numZones - 1; zone >= 0; zone--) {
                    const zoneStartX = zone * zoneDepth;
                    const zoneEndX = Math.min((zone + 1) * zoneDepth, truckDims.length);
                    
                    // Generate candidate positions based on existing boxes
                    const candidates = generateStackingPositions(packedBoxes, zoneStartX, zoneEndX);
                    
                    for (const pos of candidates) {
                        for (const rot of rotations) {
                            if (canPlaceBox(pos, rot.l, rot.w, box.height, packedBoxes)) {
                                const score = -pos.x * 10000 + pos.y * 10 + pos.z * 0.1;
                                if (score < bestScore) {
                                    bestScore = score;
                                    bestPoint = { ...pos };
                                    bestRotation = rot.rotated;
                                }
                            }
                        }
                    }
                    
                    if (bestPoint) break;
                }
                
                if (bestPoint) {
                    const l = bestRotation ? box.width : box.length;
                    const w = bestRotation ? box.length : box.width;
                    
                    box.packed = true;
                    box.position = { ...bestPoint };
                    box.packedDims = { length: l, width: w, height: box.height };
                    box.rotated = bestRotation;
                    packedBoxes.push(box);
                    
                    // Animate: box enters from rear, worker carries it to position
                    await animateHumanLoading(box);
                    
                    updateStats();
                    updateBoxList();
                }
                
                await sleep(100);
            }
            
            updateStatus(`Loaded ${packedBoxes.length}/${boxes.length} packages`);
            
            // Close doors after loading
            await sleep(500);
            if (doorsOpen) {
                toggleDoors();
            }
        }
        
        // Realistic animation: box enters through rear doors, moves horizontally to position
        // If stacking, box slides in low then lifts up
        function animateHumanLoading(box) {
            return new Promise(resolve => {
                const config = TRUCK_CONFIGS[currentTruckType];
                const wheelR = config.wheelRadius * SCALE;
                const floorHeight = wheelR * 1.3 + 0.04;
                
                const l = box.packedDims.length * SCALE;
                const h = box.packedDims.height * SCALE;
                const w = box.packedDims.width * SCALE;
                
                const boxMaterial = new THREE.MeshStandardMaterial({
                    color: box.color,
                    roughness: 0.8,
                    metalness: 0.0
                });
                
                const geometry = new THREE.BoxGeometry(l * 0.98, h * 0.98, w * 0.98);
                const mesh = new THREE.Mesh(geometry, boxMaterial);
                
                const cargoL = truckDims.length * SCALE;
                const cargoW = truckDims.width * SCALE;
                
                // Final position in the truck
                const targetX = box.position.x * SCALE + l/2 - cargoL/2;
                const targetY = floorHeight + box.position.y * SCALE + h/2;
                const targetZ = box.position.z * SCALE + w/2 - cargoW/2;
                
                // Start position: outside the truck at rear door level (worker carrying box)
                const startX = -cargoL/2 - 1.5; // Behind the truck (at the doors)
                const carryHeight = floorHeight + h/2 + 0.3; // Worker holds box at waist height
                
                mesh.position.set(startX, carryHeight, targetZ);
                
                // Add cardboard details
                const edges = new THREE.EdgesGeometry(geometry);
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0x5D4037 });
                const wireframe = new THREE.LineSegments(edges, lineMaterial);
                mesh.add(wireframe);
                
                const tapeGeo = new THREE.BoxGeometry(l * 0.15, 0.01, w * 0.98);
                const tapeMaterial = new THREE.MeshStandardMaterial({ color: 0xD2B48C });
                const tape = new THREE.Mesh(tapeGeo, tapeMaterial);
                tape.position.y = h/2;
                mesh.add(tape);
                
                if (box.fragile) {
                    const stickerGeo = new THREE.PlaneGeometry(l * 0.4, h * 0.3);
                    const stickerMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xFF0000,
                        side: THREE.DoubleSide
                    });
                    const sticker = new THREE.Mesh(stickerGeo, stickerMaterial);
                    sticker.rotation.y = Math.PI / 2;
                    sticker.position.x = l/2 + 0.001;
                    mesh.add(sticker);
                }
                
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                
                scene.add(mesh);
                packedMeshes.push(mesh);
                
                // Animation phases:
                // 1. Enter truck through rear doors (move from outside to inside)
                // 2. Walk to the position (move along X axis)
                // 3. Place/stack the box (lower to final Y position)
                
                const phase1Duration = 300; // Enter truck
                const phase2Duration = 400; // Walk to position
                const phase3Duration = 250; // Place box
                const totalDuration = phase1Duration + phase2Duration + phase3Duration;
                
                const startTime = Date.now();
                
                // Intermediate point: just inside the truck doors
                const entryX = -cargoL/2 + 0.3;
                
                function animateMove() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / totalDuration, 1);
                    
                    if (elapsed < phase1Duration) {
                        // Phase 1: Enter through doors
                        const p = elapsed / phase1Duration;
                        const eased = 1 - Math.pow(1 - p, 2);
                        mesh.position.x = startX + (entryX - startX) * eased;
                        mesh.position.y = carryHeight;
                    } else if (elapsed < phase1Duration + phase2Duration) {
                        // Phase 2: Walk to position (horizontal movement)
                        const p = (elapsed - phase1Duration) / phase2Duration;
                        const eased = p; // Linear for walking
                        mesh.position.x = entryX + (targetX - entryX) * eased;
                        mesh.position.y = carryHeight;
                    } else {
                        // Phase 3: Place the box (lower to final position)
                        const p = (elapsed - phase1Duration - phase2Duration) / phase3Duration;
                        const eased = 1 - Math.pow(1 - p, 2);
                        mesh.position.x = targetX;
                        mesh.position.y = carryHeight + (targetY - carryHeight) * eased;
                    }
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateMove);
                    } else {
                        mesh.position.set(targetX, targetY, targetZ);
                        resolve();
                    }
                }
                
                animateMove();
            });
        }
        
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        function clearPackedBoxes() {
            for (const mesh of packedMeshes) {
                scene.remove(mesh);
            }
            packedMeshes = [];
            boxes.forEach(b => { b.packed = false; b.position = null; });
        }
        
        function clearAll() {
            clearPackedBoxes();
            boxes = [];
            boxIdCounter = 0;
            updateBoxList();
            updateStats();
            updateStatus('All packages cleared');
        }
        
        function resetCamera() {
            const config = TRUCK_CONFIGS[currentTruckType];
            const cargoL = truckDims.length * SCALE;
            const distance = Math.max(12, cargoL * 1.5);
            
            camera.position.set(distance, distance * 0.6, distance);
            camera.lookAt(0, 1, 0);
            controls.target.set(0, 1, 0);
            controls.update();
        }
        
        function updateStats() {
            const config = TRUCK_CONFIGS[currentTruckType];
            const packedCount = boxes.filter(b => b.packed).length;
            const usedVolume = boxes.filter(b => b.packed)
                .reduce((sum, b) => sum + b.length * b.width * b.height, 0);
            const totalVolume = truckDims.length * truckDims.width * truckDims.height;
            const usedWeight = boxes.filter(b => b.packed)
                .reduce((sum, b) => sum + b.weight, 0);
            
            document.getElementById('stat-boxes').textContent = boxes.length;
            document.getElementById('stat-packed').textContent = packedCount;
            document.getElementById('stat-volume').textContent = 
                ((usedVolume / totalVolume) * 100).toFixed(1) + '%';
            document.getElementById('stat-weight').textContent = 
                `${usedWeight} / ${maxWeight} kg`;
            document.getElementById('progress-fill').style.width = 
                ((usedVolume / totalVolume) * 100) + '%';
        }
        
        function updateBoxList() {
            const list = document.getElementById('box-list');
            list.innerHTML = boxes.map(box => `
                <div class="box-item">
                    <div class="box-color" style="background-color: #${box.color.toString(16).padStart(6, '0')}"></div>
                    <div class="box-info">
                        <div>üì¶ #${box.id} ${box.packed ? '‚úÖ' : '‚è≥'} ${box.fragile ? '‚ö†Ô∏è' : ''}</div>
                        <div class="box-dims">${box.length}√ó${box.width}√ó${box.height}cm, ${box.weight}kg, Seq: ${box.sequence}</div>
                    </div>
                </div>
            `).join('');
        }
        
        function updateStatus(message) {
            document.getElementById('loading-status').textContent = message;
        }
        
        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        window.onload = init;
    </script>
</body>
</html>
