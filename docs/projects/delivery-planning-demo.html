<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Truck Loading Simulation - Delivery Planning System</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            overflow: hidden;
        }
        
        #container {
            display: flex;
            height: 100vh;
        }
        
        #sidebar {
            width: 350px;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #canvas-container {
            flex: 1;
            position: relative;
        }
        
        h1 {
            font-size: 1.5rem;
            margin-bottom: 10px;
            color: #4ecdc4;
        }
        
        h2 {
            font-size: 1.1rem;
            margin: 20px 0 10px;
            color: #ff6b6b;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 5px;
        }
        
        .subtitle {
            font-size: 0.85rem;
            color: #aaa;
            margin-bottom: 20px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9rem;
            color: #ccc;
        }
        
        input[type="number"], select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 0.9rem;
        }
        
        input[type="number"]:focus, select:focus {
            outline: none;
            border-color: #4ecdc4;
        }
        
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s ease;
            margin: 5px 5px 5px 0;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #4ecdc4 0%, #44a08d 100%);
            color: #fff;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(78, 205, 196, 0.4);
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a5a 100%);
            color: #fff;
        }
        
        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255, 107, 107, 0.4);
        }
        
        #stats {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }
        
        .stat-label {
            color: #aaa;
        }
        
        .stat-value {
            color: #4ecdc4;
            font-weight: 600;
        }
        
        #box-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }
        
        .box-item {
            display: flex;
            align-items: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            margin-bottom: 5px;
            font-size: 0.85rem;
        }
        
        .box-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            margin-right: 10px;
        }
        
        .box-info {
            flex: 1;
        }
        
        .box-dims {
            color: #aaa;
            font-size: 0.8rem;
        }
        
        #info-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border-radius: 8px;
            font-size: 0.9rem;
        }
        
        #loading-status {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 30px;
            border-radius: 20px;
            font-size: 0.9rem;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            margin-top: 10px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ecdc4, #44a08d);
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        
        .dimension-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
        }
        
        .dimension-inputs input {
            text-align: center;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
        }
        
        .truck-type-select {
            margin-bottom: 15px;
        }
        
        .door-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .door-controls button {
            flex: 1;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="sidebar">
            <h1>üöö 3D Truck Loading</h1>
            <p class="subtitle">Interactive Bin Packing Simulation</p>
            
            <h2>üöõ Select Truck Type</h2>
            <div class="truck-type-select">
                <select id="truck-type" onchange="changeTruckType()">
                    <option value="small_van">Small Van (300√ó150√ó180 cm)</option>
                    <option value="medium_truck">Medium Truck (450√ó200√ó220 cm)</option>
                    <option value="large_truck" selected>Large Truck (600√ó250√ó270 cm)</option>
                    <option value="semi_trailer">Semi Trailer (1350√ó250√ó280 cm)</option>
                </select>
            </div>
            <div class="door-controls">
                <button class="btn-secondary" onclick="toggleDoors()">üö™ Toggle Doors</button>
            </div>
            
            <h2>üì¶ Add Package</h2>
            <div class="dimension-inputs">
                <div class="control-group">
                    <label>Length</label>
                    <input type="number" id="box-length" value="50" min="10" max="200">
                </div>
                <div class="control-group">
                    <label>Width</label>
                    <input type="number" id="box-width" value="40" min="10" max="200">
                </div>
                <div class="control-group">
                    <label>Height</label>
                    <input type="number" id="box-height" value="30" min="10" max="200">
                </div>
            </div>
            <div class="control-group">
                <label>Weight (kg)</label>
                <input type="number" id="box-weight" value="10" min="1" max="500">
            </div>
            <div class="control-group">
                <label>Delivery Sequence (1 = first)</label>
                <input type="number" id="box-sequence" value="1" min="1" max="100">
            </div>
            <div class="control-group checkbox-group">
                <input type="checkbox" id="box-fragile">
                <label for="box-fragile">Fragile Item ‚ö†Ô∏è</label>
            </div>
            <button class="btn-primary" onclick="addBox()">‚ûï Add Package</button>
            <button class="btn-secondary" onclick="addRandomBoxes()">üé≤ Add 10 Random</button>
            
            <h2>üéÆ Controls</h2>
            <button class="btn-primary" onclick="runPacking()">‚ñ∂Ô∏è Run Packing</button>
            <button class="btn-primary" onclick="animatePacking()">üé¨ Animate Load</button>
            <button class="btn-secondary" onclick="resetCamera()">üé• Reset View</button>
            <button class="btn-danger" onclick="clearAll()">üóëÔ∏è Clear All</button>
            
            <h2>üìä Statistics</h2>
            <div id="stats">
                <div class="stat-row">
                    <span class="stat-label">Truck Type:</span>
                    <span class="stat-value" id="stat-truck">Large Truck</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Cargo Space:</span>
                    <span class="stat-value" id="stat-space">600√ó250√ó270 cm</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Boxes Added:</span>
                    <span class="stat-value" id="stat-boxes">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Boxes Packed:</span>
                    <span class="stat-value" id="stat-packed">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Volume Used:</span>
                    <span class="stat-value" id="stat-volume">0%</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Weight Used:</span>
                    <span class="stat-value" id="stat-weight">0 / 5000 kg</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
                </div>
            </div>
            
            <h2>üìã Package List</h2>
            <div id="box-list"></div>
        </div>
        
        <div id="canvas-container">
            <div id="info-overlay">
                <strong>Controls:</strong><br>
                üñ±Ô∏è Left click + drag: Rotate<br>
                üñ±Ô∏è Right click + drag: Pan<br>
                üñ±Ô∏è Scroll: Zoom
            </div>
            <div id="loading-status">Ready to load</div>
        </div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let truckGroup;
        let cargoFloor;
        let leftDoor, rightDoor;
        let doorsOpen = true;
        let boxes = [];
        let packedMeshes = [];
        let boxIdCounter = 0;
        
        // Truck configurations
        const TRUCK_CONFIGS = {
            small_van: {
                name: 'Small Van',
                cargo: { length: 300, width: 150, height: 180 },
                maxWeight: 1000,
                cabLength: 120,
                wheelRadius: 35,
                color: 0x2196F3,
                isVan: true
            },
            medium_truck: {
                name: 'Medium Truck',
                cargo: { length: 450, width: 200, height: 220 },
                maxWeight: 3000,
                cabLength: 150,
                wheelRadius: 45,
                color: 0xFF9800
            },
            large_truck: {
                name: 'Large Truck',
                cargo: { length: 600, width: 250, height: 270 },
                maxWeight: 5000,
                cabLength: 180,
                wheelRadius: 50,
                color: 0xE53935
            },
            semi_trailer: {
                name: 'Semi Trailer',
                cargo: { length: 1350, width: 250, height: 280 },
                maxWeight: 25000,
                cabLength: 200,
                wheelRadius: 55,
                color: 0x1565C0,
                isTrailer: true
            }
        };
        
        let currentTruckType = 'large_truck';
        let truckDims = { ...TRUCK_CONFIGS.large_truck.cargo };
        let maxWeight = TRUCK_CONFIGS.large_truck.maxWeight;
        
        const SCALE = 0.01;
        
        // Color palette for boxes (cardboard colors)
        const BOX_COLORS = [
            0x8D6E63, 0xA1887F, 0xBCAAA4, 0x795548,
            0xD7CCC8, 0x6D4C41, 0x5D4037, 0x4E342E,
            0xFFCC80, 0xFFE0B2, 0xFFB74D, 0xFFA726
        ];
        
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue
            
            // Add fog for depth
            scene.fog = new THREE.Fog(0x87CEEB, 20, 100);
            
            const container = document.getElementById('canvas-container');
            camera = new THREE.PerspectiveCamera(
                50,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            camera.position.set(12, 6, 12);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 50;
            controls.maxPolarAngle = Math.PI / 2;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
            sunLight.position.set(20, 30, 20);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 100;
            sunLight.shadow.camera.left = -20;
            sunLight.shadow.camera.right = 20;
            sunLight.shadow.camera.top = 20;
            sunLight.shadow.camera.bottom = -20;
            scene.add(sunLight);
            
            // Ground
            createGround();
            
            // Create truck
            createTruck();
            
            window.addEventListener('resize', onWindowResize);
            animate();
        }
        
        function createGround() {
            // Asphalt ground
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x3a3a3a,
                roughness: 0.9,
                metalness: 0.1
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.01;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Road markings
            const lineGeometry = new THREE.PlaneGeometry(0.15, 50);
            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
            
            for (let i = -2; i <= 2; i++) {
                const line = new THREE.Mesh(lineGeometry, lineMaterial);
                line.rotation.x = -Math.PI / 2;
                line.position.set(i * 3, 0.01, 0);
                scene.add(line);
            }
            
            // Warehouse floor area
            const warehouseGeometry = new THREE.PlaneGeometry(15, 20);
            const warehouseMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x606060,
                roughness: 0.7
            });
            const warehouse = new THREE.Mesh(warehouseGeometry, warehouseMaterial);
            warehouse.rotation.x = -Math.PI / 2;
            warehouse.position.set(-12, 0.02, 0);
            warehouse.receiveShadow = true;
            scene.add(warehouse);
        }
        
        function createTruck() {
            if (truckGroup) {
                scene.remove(truckGroup);
            }
            
            truckGroup = new THREE.Group();
            const config = TRUCK_CONFIGS[currentTruckType];
            
            const cargoL = truckDims.length * SCALE;
            const cargoW = truckDims.width * SCALE;
            const cargoH = truckDims.height * SCALE;
            const cabL = config.cabLength * SCALE;
            const wheelR = config.wheelRadius * SCALE;
            const floorHeight = wheelR * 1.3;
            
            // Materials
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: config.color,
                roughness: 0.3,
                metalness: 0.6
            });
            
            const whiteMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xF5F5F5,
                roughness: 0.4,
                metalness: 0.2
            });
            
            const darkMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a1a,
                roughness: 0.8
            });
            
            const glassMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x87CEEB,
                transparent: true,
                opacity: 0.6,
                roughness: 0.1,
                metalness: 0.9
            });
            
            const cargoMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xEEEEEE,
                roughness: 0.5,
                metalness: 0.3
            });
            
            // === CARGO BOX ===
            const cargoGroup = new THREE.Group();
            
            // Cargo floor
            const floorThickness = 0.08;
            const floorGeo = new THREE.BoxGeometry(cargoL, floorThickness, cargoW);
            cargoFloor = new THREE.Mesh(floorGeo, darkMaterial);
            cargoFloor.position.set(cargoL/2, floorHeight, cargoW/2);
            cargoFloor.castShadow = true;
            cargoFloor.receiveShadow = true;
            cargoGroup.add(cargoFloor);
            
            // Cargo walls
            const wallThickness = 0.05;
            
            // Left wall
            const leftWallGeo = new THREE.BoxGeometry(cargoL, cargoH, wallThickness);
            const leftWall = new THREE.Mesh(leftWallGeo, cargoMaterial);
            leftWall.position.set(cargoL/2, floorHeight + cargoH/2, wallThickness/2);
            leftWall.castShadow = true;
            cargoGroup.add(leftWall);
            
            // Right wall
            const rightWall = new THREE.Mesh(leftWallGeo, cargoMaterial);
            rightWall.position.set(cargoL/2, floorHeight + cargoH/2, cargoW - wallThickness/2);
            rightWall.castShadow = true;
            cargoGroup.add(rightWall);
            
            // Front wall (behind cab)
            const frontWallGeo = new THREE.BoxGeometry(wallThickness, cargoH, cargoW);
            const frontWall = new THREE.Mesh(frontWallGeo, cargoMaterial);
            frontWall.position.set(cargoL - wallThickness/2, floorHeight + cargoH/2, cargoW/2);
            frontWall.castShadow = true;
            cargoGroup.add(frontWall);
            
            // Roof
            const roofGeo = new THREE.BoxGeometry(cargoL, wallThickness, cargoW);
            const roof = new THREE.Mesh(roofGeo, cargoMaterial);
            roof.position.set(cargoL/2, floorHeight + cargoH, cargoW/2);
            roof.castShadow = true;
            cargoGroup.add(roof);
            
            // === REAR DOORS ===
            // Doors swing outward from hinges at the outer edges of the truck
            const doorWidth = (cargoW - wallThickness * 2) / 2;
            const doorGeo = new THREE.BoxGeometry(wallThickness * 2, cargoH * 0.95, doorWidth);
            
            // Left door - hinge is at z=0 (left edge of truck)
            leftDoor = new THREE.Group();
            const leftDoorMesh = new THREE.Mesh(doorGeo, cargoMaterial);
            // Position door mesh so pivot point is at the hinge (outer edge)
            leftDoorMesh.position.set(wallThickness, 0, doorWidth/2);
            leftDoor.add(leftDoorMesh);
            
            // Door handle left (on the inner edge, near center of truck)
            const handleGeo = new THREE.BoxGeometry(0.08, 0.3, 0.05);
            const leftHandle = new THREE.Mesh(handleGeo, darkMaterial);
            leftHandle.position.set(wallThickness * 2 + 0.02, 0, doorWidth - 0.15);
            leftDoor.add(leftHandle);
            
            // Position left door group at the hinge point (left outer edge at rear)
            leftDoor.position.set(0, floorHeight + cargoH/2, 0);
            cargoGroup.add(leftDoor);
            
            // Right door - hinge is at z=cargoW (right edge of truck)
            rightDoor = new THREE.Group();
            const rightDoorMesh = new THREE.Mesh(doorGeo, cargoMaterial);
            // Position door mesh so pivot point is at the hinge (outer edge)
            rightDoorMesh.position.set(wallThickness, 0, -doorWidth/2);
            rightDoor.add(rightDoorMesh);
            
            // Door handle right (on the inner edge, near center of truck)
            const rightHandle = new THREE.Mesh(handleGeo, darkMaterial);
            rightHandle.position.set(wallThickness * 2 + 0.02, 0, -doorWidth + 0.15);
            rightDoor.add(rightHandle);
            
            // Position right door group at the hinge point (right outer edge at rear)
            rightDoor.position.set(0, floorHeight + cargoH/2, cargoW);
            cargoGroup.add(rightDoor);
            
            // Open doors by default - swing outward from hinges
            leftDoor.rotation.y = Math.PI / 2;  // Left door opens to the left
            rightDoor.rotation.y = -Math.PI / 2; // Right door opens to the right
            
            // === CAB ===
            const cabGroup = new THREE.Group();
            const cabHeight = cargoH * 0.85;
            const cabWidth = cargoW * 0.95;
            
            // Cab body
            const cabGeo = new THREE.BoxGeometry(cabL, cabHeight, cabWidth);
            const cab = new THREE.Mesh(cabGeo, bodyMaterial);
            cab.position.set(cargoL + cabL/2 + 0.1, floorHeight + cabHeight/2, cargoW/2);
            cab.castShadow = true;
            cabGroup.add(cab);
            
            // Cab roof (slightly curved effect with box)
            const cabRoofGeo = new THREE.BoxGeometry(cabL * 0.9, 0.1, cabWidth * 0.9);
            const cabRoof = new THREE.Mesh(cabRoofGeo, bodyMaterial);
            cabRoof.position.set(cargoL + cabL/2 + 0.1, floorHeight + cabHeight + 0.05, cargoW/2);
            cabRoof.castShadow = true;
            cabGroup.add(cabRoof);
            
            // Windshield
            const windshieldGeo = new THREE.BoxGeometry(0.05, cabHeight * 0.5, cabWidth * 0.8);
            const windshield = new THREE.Mesh(windshieldGeo, glassMaterial);
            windshield.position.set(cargoL + cabL + 0.1, floorHeight + cabHeight * 0.65, cargoW/2);
            cabGroup.add(windshield);
            
            // Side windows
            const sideWindowGeo = new THREE.BoxGeometry(cabL * 0.4, cabHeight * 0.35, 0.05);
            const leftWindow = new THREE.Mesh(sideWindowGeo, glassMaterial);
            leftWindow.position.set(cargoL + cabL * 0.7, floorHeight + cabHeight * 0.6, cargoW/2 - cabWidth/2);
            cabGroup.add(leftWindow);
            
            const rightWindow = new THREE.Mesh(sideWindowGeo, glassMaterial);
            rightWindow.position.set(cargoL + cabL * 0.7, floorHeight + cabHeight * 0.6, cargoW/2 + cabWidth/2);
            cabGroup.add(rightWindow);
            
            // Headlights
            const headlightGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.05, 16);
            const headlightMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFFFCC,
                emissive: 0xFFFF00,
                emissiveIntensity: 0.3
            });
            
            const leftHeadlight = new THREE.Mesh(headlightGeo, headlightMaterial);
            leftHeadlight.rotation.z = Math.PI / 2;
            leftHeadlight.position.set(cargoL + cabL + 0.12, floorHeight + cabHeight * 0.3, cargoW/2 - cabWidth * 0.35);
            cabGroup.add(leftHeadlight);
            
            const rightHeadlight = new THREE.Mesh(headlightGeo, headlightMaterial);
            rightHeadlight.rotation.z = Math.PI / 2;
            rightHeadlight.position.set(cargoL + cabL + 0.12, floorHeight + cabHeight * 0.3, cargoW/2 + cabWidth * 0.35);
            cabGroup.add(rightHeadlight);
            
            // Grille
            const grilleGeo = new THREE.BoxGeometry(0.05, cabHeight * 0.25, cabWidth * 0.5);
            const grille = new THREE.Mesh(grilleGeo, darkMaterial);
            grille.position.set(cargoL + cabL + 0.1, floorHeight + cabHeight * 0.35, cargoW/2);
            cabGroup.add(grille);
            
            // Bumper
            const bumperGeo = new THREE.BoxGeometry(0.15, 0.15, cabWidth);
            const bumper = new THREE.Mesh(bumperGeo, darkMaterial);
            bumper.position.set(cargoL + cabL + 0.15, floorHeight * 0.5, cargoW/2);
            bumper.castShadow = true;
            cabGroup.add(bumper);
            
            // Side mirrors
            const mirrorGeo = new THREE.BoxGeometry(0.1, 0.15, 0.08);
            const leftMirror = new THREE.Mesh(mirrorGeo, darkMaterial);
            leftMirror.position.set(cargoL + cabL * 0.9, floorHeight + cabHeight * 0.7, cargoW/2 - cabWidth/2 - 0.15);
            cabGroup.add(leftMirror);
            
            const rightMirror = new THREE.Mesh(mirrorGeo, darkMaterial);
            rightMirror.position.set(cargoL + cabL * 0.9, floorHeight + cabHeight * 0.7, cargoW/2 + cabWidth/2 + 0.15);
            cabGroup.add(rightMirror);
            
            // === WHEELS ===
            const wheelGroup = new THREE.Group();
            
            function createWheel(x, z) {
                const wheel = new THREE.Group();
                
                // Tire
                const tireGeo = new THREE.CylinderGeometry(wheelR, wheelR, wheelR * 0.4, 24);
                const tire = new THREE.Mesh(tireGeo, new THREE.MeshStandardMaterial({ 
                    color: 0x1a1a1a,
                    roughness: 0.9
                }));
                tire.rotation.x = Math.PI / 2;
                tire.castShadow = true;
                wheel.add(tire);
                
                // Hubcap
                const hubGeo = new THREE.CylinderGeometry(wheelR * 0.5, wheelR * 0.5, wheelR * 0.42, 16);
                const hub = new THREE.Mesh(hubGeo, new THREE.MeshStandardMaterial({ 
                    color: 0xCCCCCC,
                    metalness: 0.8,
                    roughness: 0.2
                }));
                hub.rotation.x = Math.PI / 2;
                wheel.add(hub);
                
                wheel.position.set(x, wheelR, z);
                return wheel;
            }
            
            // Front wheels
            wheelGroup.add(createWheel(cargoL + cabL * 0.7, cargoW/2 - cabWidth/2 - wheelR * 0.2));
            wheelGroup.add(createWheel(cargoL + cabL * 0.7, cargoW/2 + cabWidth/2 + wheelR * 0.2));
            
            // Rear wheels (dual for larger trucks)
            const rearWheelX = cargoL * 0.25;
            wheelGroup.add(createWheel(rearWheelX, cargoW/2 - cargoW/2 - wheelR * 0.2));
            wheelGroup.add(createWheel(rearWheelX, cargoW/2 + cargoW/2 + wheelR * 0.2));
            
            if (currentTruckType === 'large_truck' || currentTruckType === 'semi_trailer') {
                // Second set of rear wheels
                wheelGroup.add(createWheel(rearWheelX - wheelR * 1.2, cargoW/2 - cargoW/2 - wheelR * 0.2));
                wheelGroup.add(createWheel(rearWheelX - wheelR * 1.2, cargoW/2 + cargoW/2 + wheelR * 0.2));
            }
            
            if (currentTruckType === 'semi_trailer') {
                // Additional trailer wheels
                const midWheelX = cargoL * 0.6;
                wheelGroup.add(createWheel(midWheelX, cargoW/2 - cargoW/2 - wheelR * 0.2));
                wheelGroup.add(createWheel(midWheelX, cargoW/2 + cargoW/2 + wheelR * 0.2));
            }
            
            // === CHASSIS ===
            const chassisGeo = new THREE.BoxGeometry(cargoL + cabL + 0.2, 0.15, cargoW * 0.3);
            const chassis = new THREE.Mesh(chassisGeo, darkMaterial);
            chassis.position.set((cargoL + cabL) / 2, wheelR * 0.8, cargoW/2);
            chassis.castShadow = true;
            
            // === TAIL LIGHTS ===
            const tailLightGeo = new THREE.BoxGeometry(0.05, 0.15, 0.1);
            const tailLightMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFF0000,
                emissive: 0x330000,
                emissiveIntensity: 0.5
            });
            
            const leftTailLight = new THREE.Mesh(tailLightGeo, tailLightMaterial);
            leftTailLight.position.set(-0.03, floorHeight + 0.2, wallThickness + 0.1);
            cargoGroup.add(leftTailLight);
            
            const rightTailLight = new THREE.Mesh(tailLightGeo, tailLightMaterial);
            rightTailLight.position.set(-0.03, floorHeight + 0.2, cargoW - wallThickness - 0.1);
            cargoGroup.add(rightTailLight);
            
            // Assemble truck
            truckGroup.add(cargoGroup);
            truckGroup.add(cabGroup);
            truckGroup.add(wheelGroup);
            truckGroup.add(chassis);
            
            // Center the truck
            truckGroup.position.set(-cargoL/2, 0, -cargoW/2);
            
            scene.add(truckGroup);
            
            updateStats();
        }
        
        function toggleDoors() {
            doorsOpen = !doorsOpen;
            
            // Doors swing from hinges at outer edges
            // Open: left door rotates +90¬∞ (opens left), right door rotates -90¬∞ (opens right)
            // Closed: both doors at 0¬∞
            const leftTargetAngle = doorsOpen ? Math.PI / 2 : 0;
            const rightTargetAngle = doorsOpen ? -Math.PI / 2 : 0;
            
            // Animate doors
            const duration = 500;
            const startTime = Date.now();
            const startLeftAngle = leftDoor.rotation.y;
            const startRightAngle = rightDoor.rotation.y;
            
            function animateDoors() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = 1 - Math.pow(1 - progress, 3);
                
                leftDoor.rotation.y = startLeftAngle + (leftTargetAngle - startLeftAngle) * eased;
                rightDoor.rotation.y = startRightAngle + (rightTargetAngle - startRightAngle) * eased;
                
                if (progress < 1) {
                    requestAnimationFrame(animateDoors);
                }
            }
            
            animateDoors();
            updateStatus(doorsOpen ? 'Doors opened' : 'Doors closed');
        }
        
        function changeTruckType() {
            currentTruckType = document.getElementById('truck-type').value;
            const config = TRUCK_CONFIGS[currentTruckType];
            truckDims = { ...config.cargo };
            maxWeight = config.maxWeight;
            
            clearPackedBoxes();
            createTruck();
            resetCamera();
            
            document.getElementById('stat-truck').textContent = config.name;
            document.getElementById('stat-space').textContent = 
                `${truckDims.length}√ó${truckDims.width}√ó${truckDims.height} cm`;
            
            updateStats();
            updateStatus(`Switched to ${config.name}`);
        }
        
        function addBox() {
            const box = {
                id: ++boxIdCounter,
                length: parseInt(document.getElementById('box-length').value),
                width: parseInt(document.getElementById('box-width').value),
                height: parseInt(document.getElementById('box-height').value),
                weight: parseInt(document.getElementById('box-weight').value),
                sequence: parseInt(document.getElementById('box-sequence').value),
                fragile: document.getElementById('box-fragile').checked,
                color: BOX_COLORS[boxIdCounter % BOX_COLORS.length],
                packed: false,
                position: null
            };
            
            boxes.push(box);
            updateBoxList();
            updateStats();
            updateStatus(`Added package #${box.id}`);
        }
        
        function addRandomBoxes() {
            for (let i = 0; i < 10; i++) {
                const box = {
                    id: ++boxIdCounter,
                    length: Math.floor(Math.random() * 60) + 20,
                    width: Math.floor(Math.random() * 50) + 20,
                    height: Math.floor(Math.random() * 40) + 15,
                    weight: Math.floor(Math.random() * 30) + 5,
                    sequence: Math.floor(Math.random() * 10) + 1,
                    fragile: Math.random() > 0.85,
                    color: BOX_COLORS[boxIdCounter % BOX_COLORS.length],
                    packed: false,
                    position: null
                };
                boxes.push(box);
            }
            updateBoxList();
            updateStats();
            updateStatus(`Added 10 packages`);
        }
        
        // ============================================================
        // ADVANCED 3D BIN PACKING ALGORITHM
        // Uses Extreme Points + Best Fit Decreasing + Multiple Rotations
        // Optimized for maximum space utilization with human-realistic loading
        // ============================================================
        
        function runPacking() {
            clearPackedBoxes();
            
            if (boxes.length === 0) {
                updateStatus('No packages to load!');
                return;
            }
            
            // LIFO Loading: Sort by delivery sequence
            // Higher sequence = later delivery = loaded FIRST = goes to FRONT (cab)
            // Lower sequence = earlier delivery = loaded LAST = stays near DOORS
            const sortedBoxes = [...boxes].sort((a, b) => {
                // Primary: delivery sequence (higher = later delivery = load first)
                if (b.sequence !== a.sequence) return b.sequence - a.sequence;
                // Secondary: volume (larger boxes first for stable base)
                const volA = a.length * a.width * a.height;
                const volB = b.length * b.width * b.height;
                return volB - volA;
            });
            
            // Initialize extreme points starting from FRONT of truck (cab side)
            // Workers start at the front when truck is empty
            // x = depth (0 = rear doors, max = cab front wall)
            let extremePoints = [
                { x: truckDims.length - 1, y: 0, z: 0 },  // Front-left corner
                { x: truckDims.length - 1, y: 0, z: truckDims.width - 1 }  // Front-right corner
            ];
            const packedBoxes = [];
            
            for (const box of sortedBoxes) {
                const placement = findBestPlacement(box, extremePoints, packedBoxes);
                
                if (placement) {
                    box.packed = true;
                    box.position = { x: placement.x, y: placement.y, z: placement.z };
                    box.packedDims = { 
                        length: placement.dims.l, 
                        width: placement.dims.w, 
                        height: placement.dims.h 
                    };
                    box.rotated = placement.rotated;
                    packedBoxes.push(box);
                    
                    // Update extreme points after placing box
                    extremePoints = updateExtremePoints(extremePoints, box, packedBoxes);
                }
            }
            
            for (const box of packedBoxes) {
                createBoxMesh(box);
            }
            
            updateStats();
            updateBoxList();
            
            const utilization = calculateUtilization(packedBoxes);
            updateStatus(`Loaded ${packedBoxes.length}/${boxes.length} (${utilization.toFixed(1)}% volume used)`);
        }
        
        // Find the best placement for a box using Extreme Points algorithm
        // For LIFO: positions box so it fits against the front or existing boxes
        function findBestPlacement(box, extremePoints, packedBoxes) {
            let bestPlacement = null;
            let bestScore = -Infinity;
            
            // Try all 6 possible orientations of the box
            const orientations = getBoxOrientations(box);
            
            for (const ep of extremePoints) {
                for (const dims of orientations) {
                    // For front-to-back loading, adjust X so box fits within bounds
                    // The extreme point is where the box's back edge should be
                    // So the box extends from ep.x to ep.x + dims.l
                    // But if ep is near front wall, we need to push box back
                    let adjustedX = ep.x;
                    if (adjustedX + dims.l > truckDims.length) {
                        adjustedX = truckDims.length - dims.l;
                    }
                    
                    const adjustedPos = { x: adjustedX, y: ep.y, z: ep.z };
                    
                    if (canPlaceBoxAt(adjustedPos, dims.l, dims.w, dims.h, packedBoxes)) {
                        const score = calculatePlacementScore(adjustedPos, dims, packedBoxes);
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestPlacement = {
                                x: adjustedPos.x,
                                y: adjustedPos.y,
                                z: adjustedPos.z,
                                dims: dims,
                                rotated: dims.rotated
                            };
                        }
                    }
                }
            }
            
            return bestPlacement;
        }
        
        // Get all 6 possible orientations of a box
        function getBoxOrientations(box) {
            const l = box.length, w = box.width, h = box.height;
            
            // For human loading, we typically keep boxes upright
            // But allow rotation in the horizontal plane
            // Also allow laying flat if it helps
            return [
                { l: l, w: w, h: h, rotated: false },   // Original
                { l: w, w: l, h: h, rotated: true },    // Rotated 90¬∞ horizontal
                { l: l, w: h, h: w, rotated: 'side1' }, // On side
                { l: h, w: l, h: w, rotated: 'side2' }, // On side rotated
                { l: w, w: h, h: l, rotated: 'flat1' }, // Flat
                { l: h, w: w, h: l, rotated: 'flat2' }  // Flat rotated
            ];
        }
        
        // Calculate a score for placing a box at a given position
        // LIFO DELIVERY OPTIMIZATION: Load last-delivery items first (deepest in truck)
        // Workers start at front (cab), build walls moving backward toward doors
        // When truck is empty, workers CAN reach the front - so start there!
        // Result: First delivery items are near doors, easy to grab
        function calculatePlacementScore(pos, dims, packedBoxes) {
            let score = 0;
            
            // COLUMN-BASED LOADING (build walls from FRONT to BACK for LIFO)
            // Divide truck into columns along the length (~80cm each)
            const columnDepth = 80;
            const currentColumn = Math.floor(pos.x / columnDepth);
            const maxColumn = Math.floor(truckDims.length / columnDepth);
            
            // 1. PREFER FRONT (high X) columns first - this is LIFO loading!
            // Last delivery items go deepest, first delivery items near doors
            // Higher X = front of truck = loaded FIRST = delivered LAST
            score += currentColumn * 100000;
            
            // 2. Check if current front column is filled before moving back
            // Only move to next column (toward doors) if current one is well-filled
            if (currentColumn < maxColumn) {
                const currentColFill = getColumnFillRatio(currentColumn, columnDepth, packedBoxes);
                const nextColFill = getColumnFillRatio(currentColumn + 1, columnDepth, packedBoxes);
                
                // If front columns aren't filled yet, prefer them
                for (let c = maxColumn; c > currentColumn; c--) {
                    const frontColFill = getColumnFillRatio(c, columnDepth, packedBoxes);
                    if (frontColFill < 0.5) {
                        // There's space in a front column, penalize this back position
                        score -= 30000;
                        break;
                    }
                }
            }
            
            // 3. Within a column, fill floor first then stack
            // This builds stable walls
            if (pos.y < 1) {
                score += 10000; // Floor positions get bonus
            }
            
            // 4. Stacking is good in the current active column
            if (pos.y > 0) {
                const activeCol = getActiveColumn(packedBoxes, columnDepth);
                if (currentColumn >= activeCol) {
                    // Reward stacking in the front columns we're filling
                    score += 15000;
                }
            }
            
            // 5. Within column, fill left to right
            score -= (pos.z / truckDims.width) * 100;
            
            // 6. Reward positions that fit snugly against walls or other boxes
            const contactScore = calculateContactScore(pos, dims, packedBoxes);
            score += contactScore * 500;
            
            // 7. Penalize positions that create hard-to-fill gaps
            const gapPenalty = calculateGapPenalty(pos, dims, packedBoxes);
            score -= gapPenalty * 200;
            
            // 8. Bonus for stacking directly on top of another box
            if (pos.y > 0) {
                const directSupport = getDirectSupportScore(pos, dims, packedBoxes);
                score += directSupport * 1000;
            }
            
            // 9. Prefer keeping boxes upright
            if (dims.rotated === false) score += 20;
            else if (dims.rotated === true) score += 15;
            
            return score;
        }
        
        // Calculate how filled a column is (floor coverage ratio)
        function getColumnFillRatio(columnIndex, columnDepth, packedBoxes) {
            const columnStartX = columnIndex * columnDepth;
            const columnEndX = Math.min((columnIndex + 1) * columnDepth, truckDims.length);
            const columnArea = (columnEndX - columnStartX) * truckDims.width;
            
            let floorCoverage = 0;
            for (const box of packedBoxes) {
                if (box.position.y < 5) { // Floor level boxes only
                    const overlapX = Math.max(0,
                        Math.min(box.position.x + box.packedDims.length, columnEndX) -
                        Math.max(box.position.x, columnStartX)
                    );
                    if (overlapX > 0) {
                        floorCoverage += overlapX * box.packedDims.width;
                    }
                }
            }
            
            return floorCoverage / columnArea;
        }
        
        // Get the current active loading column (the one workers are filling)
        function getActiveColumn(packedBoxes, columnDepth) {
            // Find the furthest column that has any boxes
            let activeColumn = 0;
            for (const box of packedBoxes) {
                const boxColumn = Math.floor(box.position.x / columnDepth);
                activeColumn = Math.max(activeColumn, boxColumn);
            }
            return activeColumn;
        }
        
        // Calculate how well a position is directly supported by boxes below
        function getDirectSupportScore(pos, dims, packedBoxes) {
            let supportScore = 0;
            const l = dims.l, w = dims.w;
            const boxArea = l * w;
            
            for (const packed of packedBoxes) {
                const packedTop = packed.position.y + packed.packedDims.height;
                // Check if this box is directly below (within 2cm)
                if (Math.abs(packedTop - pos.y) < 2) {
                    const overlapX = Math.max(0, 
                        Math.min(pos.x + l, packed.position.x + packed.packedDims.length) -
                        Math.max(pos.x, packed.position.x)
                    );
                    const overlapZ = Math.max(0,
                        Math.min(pos.z + w, packed.position.z + packed.packedDims.width) -
                        Math.max(pos.z, packed.position.z)
                    );
                    const overlapArea = overlapX * overlapZ;
                    
                    // Bonus for centered support (box sitting squarely on another)
                    if (overlapArea / boxArea > 0.7) {
                        supportScore += 1.0;
                    } else if (overlapArea / boxArea > 0.5) {
                        supportScore += 0.5;
                    }
                }
            }
            return supportScore;
        }
        
        // Calculate how much contact area the box has with walls and other boxes
        function calculateContactScore(pos, dims, packedBoxes) {
            let contactArea = 0;
            const l = dims.l, w = dims.w, h = dims.h;
            
            // Contact with floor
            if (pos.y === 0) {
                contactArea += l * w;
            }
            
            // Contact with front wall (cab side)
            if (pos.x + l >= truckDims.length - 1) {
                contactArea += w * h;
            }
            
            // Contact with left wall
            if (pos.z === 0) {
                contactArea += l * h;
            }
            
            // Contact with right wall
            if (pos.z + w >= truckDims.width - 1) {
                contactArea += l * h;
            }
            
            // Contact with other boxes
            for (const packed of packedBoxes) {
                const p = packed.position;
                const d = packed.packedDims;
                
                // Check bottom contact (sitting on top of another box)
                if (Math.abs(pos.y - (p.y + d.height)) < 1) {
                    const overlapL = Math.max(0, Math.min(pos.x + l, p.x + d.length) - Math.max(pos.x, p.x));
                    const overlapW = Math.max(0, Math.min(pos.z + w, p.z + d.width) - Math.max(pos.z, p.z));
                    contactArea += overlapL * overlapW * 1.5; // Bonus for stacking
                }
                
                // Check side contacts
                // Right side of new box touching left side of packed box
                if (Math.abs((pos.z + w) - p.z) < 1) {
                    const overlapL = Math.max(0, Math.min(pos.x + l, p.x + d.length) - Math.max(pos.x, p.x));
                    const overlapH = Math.max(0, Math.min(pos.y + h, p.y + d.height) - Math.max(pos.y, p.y));
                    contactArea += overlapL * overlapH * 0.5;
                }
                // Left side touching right side
                if (Math.abs(pos.z - (p.z + d.width)) < 1) {
                    const overlapL = Math.max(0, Math.min(pos.x + l, p.x + d.length) - Math.max(pos.x, p.x));
                    const overlapH = Math.max(0, Math.min(pos.y + h, p.y + d.height) - Math.max(pos.y, p.y));
                    contactArea += overlapL * overlapH * 0.5;
                }
                // Front/back contacts
                if (Math.abs((pos.x + l) - p.x) < 1) {
                    const overlapW = Math.max(0, Math.min(pos.z + w, p.z + d.width) - Math.max(pos.z, p.z));
                    const overlapH = Math.max(0, Math.min(pos.y + h, p.y + d.height) - Math.max(pos.y, p.y));
                    contactArea += overlapW * overlapH * 0.5;
                }
                if (Math.abs(pos.x - (p.x + d.length)) < 1) {
                    const overlapW = Math.max(0, Math.min(pos.z + w, p.z + d.width) - Math.max(pos.z, p.z));
                    const overlapH = Math.max(0, Math.min(pos.y + h, p.y + d.height) - Math.max(pos.y, p.y));
                    contactArea += overlapW * overlapH * 0.5;
                }
            }
            
            // Normalize by box surface area
            const totalSurface = 2 * (l * w + l * h + w * h);
            return contactArea / totalSurface;
        }
        
        // Calculate penalty for creating hard-to-fill gaps
        function calculateGapPenalty(pos, dims, packedBoxes) {
            let penalty = 0;
            const l = dims.l, w = dims.w, h = dims.h;
            
            // Check for small gaps that would be hard to fill
            const minUsableGap = 15; // 15cm minimum useful gap
            
            // Gap to left wall
            if (pos.z > 0 && pos.z < minUsableGap) {
                penalty += pos.z / minUsableGap;
            }
            
            // Gap to right wall  
            const rightGap = truckDims.width - (pos.z + w);
            if (rightGap > 0 && rightGap < minUsableGap) {
                penalty += rightGap / minUsableGap;
            }
            
            // Gap to front (cab)
            const frontGap = truckDims.length - (pos.x + l);
            if (frontGap > 0 && frontGap < minUsableGap) {
                penalty += frontGap / minUsableGap;
            }
            
            // Gap above (ceiling)
            const topGap = truckDims.height - (pos.y + h);
            if (topGap > 0 && topGap < minUsableGap) {
                penalty += topGap / minUsableGap * 0.5; // Less important
            }
            
            return penalty;
        }
        
        // Check if a box can be placed at a given position
        function canPlaceBoxAt(pos, length, width, height, packedBoxes) {
            // Check bounds
            if (pos.x < 0 || pos.y < 0 || pos.z < 0) return false;
            if (pos.x + length > truckDims.length) return false;
            if (pos.y + height > truckDims.height) return false;
            if (pos.z + width > truckDims.width) return false;
            
            // Check collision with existing boxes
            for (const packed of packedBoxes) {
                if (boxesIntersect(
                    pos.x, pos.y, pos.z, length, height, width,
                    packed.position.x, packed.position.y, packed.position.z,
                    packed.packedDims.length, packed.packedDims.height, packed.packedDims.width
                )) {
                    return false;
                }
            }
            
            // Check support (must be on floor or have adequate support from below)
            if (pos.y > 0.5) {
                let supportArea = 0;
                const boxArea = length * width;
                let supportingBoxes = [];
                
                for (const packed of packedBoxes) {
                    const packedTop = packed.position.y + packed.packedDims.height;
                    if (Math.abs(packedTop - pos.y) < 2) {
                        const overlapX = Math.max(0, 
                            Math.min(pos.x + length, packed.position.x + packed.packedDims.length) -
                            Math.max(pos.x, packed.position.x)
                        );
                        const overlapZ = Math.max(0,
                            Math.min(pos.z + width, packed.position.z + packed.packedDims.width) -
                            Math.max(pos.z, packed.position.z)
                        );
                        if (overlapX > 0 && overlapZ > 0) {
                            supportArea += overlapX * overlapZ;
                            supportingBoxes.push({ box: packed, overlapX, overlapZ });
                        }
                    }
                }
                
                // Need at least 60% support for stability (increased from 50%)
                if (supportArea / boxArea < 0.6) return false;
                
                // Additional stability check: center of mass should be over support
                // The box's center should be within the support area
                const boxCenterX = pos.x + length / 2;
                const boxCenterZ = pos.z + width / 2;
                
                let centerSupported = false;
                for (const support of supportingBoxes) {
                    const sp = support.box.position;
                    const sd = support.box.packedDims;
                    if (boxCenterX >= sp.x && boxCenterX <= sp.x + sd.length &&
                        boxCenterZ >= sp.z && boxCenterZ <= sp.z + sd.width) {
                        centerSupported = true;
                        break;
                    }
                }
                
                // If center isn't over any single box, need even more support
                if (!centerSupported && supportArea / boxArea < 0.75) return false;
            }
            
            return true;
        }
        
        // Update extreme points after placing a box
        // For LIFO: generate points that help fill from front to back
        function updateExtremePoints(currentPoints, placedBox, packedBoxes) {
            const pos = placedBox.position;
            const dims = placedBox.packedDims;
            
            // Generate new extreme points from the placed box
            const newPoints = [
                // Point toward doors (lower X = toward back/doors)
                { x: pos.x - 1, y: pos.y, z: pos.z },
                // Point to the right of the box (along Z)
                { x: pos.x, y: pos.y, z: pos.z + dims.width },
                // Point on top of placed box (for stacking)
                { x: pos.x, y: pos.y + dims.height, z: pos.z },
                // Top corners for more stacking options
                { x: pos.x, y: pos.y + dims.height, z: pos.z + dims.width },
            ];
            
            // Add points behind the box (toward doors) at floor level
            if (pos.x > 0) {
                newPoints.push({ x: pos.x - dims.length, y: 0, z: pos.z });
                newPoints.push({ x: pos.x - dims.length, y: 0, z: pos.z + dims.width });
            }
            
            // Add floor points in the same column
            newPoints.push({ x: pos.x, y: 0, z: pos.z + dims.width });
            
            // Combine with existing points
            let allPoints = [...currentPoints, ...newPoints];
            
            // Remove points that are now inside boxes
            allPoints = allPoints.filter(p => !isPointInsideAnyBox(p, packedBoxes));
            
            // Remove points outside truck bounds
            allPoints = allPoints.filter(p => 
                p.x >= 0 && p.x <= truckDims.length &&
                p.y >= 0 && p.y < truckDims.height &&
                p.z >= 0 && p.z <= truckDims.width
            );
            
            // Remove duplicate points
            const uniquePoints = [];
            const seen = new Set();
            for (const p of allPoints) {
                const key = `${Math.round(p.x)},${Math.round(p.y)},${Math.round(p.z)}`;
                if (!seen.has(key)) {
                    seen.add(key);
                    uniquePoints.push(p);
                }
            }
            
            // Sort by priority: FRONT first (high x), then FLOOR (low y), then LEFT (low z)
            // This ensures we fill front column, stack it, then move toward doors
            uniquePoints.sort((a, b) => {
                // Primary: higher X = front of truck = fill first
                if (Math.abs(b.x - a.x) > 5) return b.x - a.x;
                // Secondary: lower Y = floor first, then stack
                if (Math.abs(a.y - b.y) > 5) return a.y - b.y;
                // Tertiary: lower Z = left side first
                return a.z - b.z;
            });
            
            return uniquePoints;
        }
        
        // Check if a point is inside any packed box
        function isPointInsideAnyBox(point, packedBoxes) {
            for (const box of packedBoxes) {
                const p = box.position;
                const d = box.packedDims;
                if (point.x >= p.x && point.x < p.x + d.length &&
                    point.y >= p.y && point.y < p.y + d.height &&
                    point.z >= p.z && point.z < p.z + d.width) {
                    return true;
                }
            }
            return false;
        }
        
        // Calculate volume utilization percentage
        function calculateUtilization(packedBoxes) {
            const usedVolume = packedBoxes.reduce((sum, b) => 
                sum + b.packedDims.length * b.packedDims.width * b.packedDims.height, 0);
            const totalVolume = truckDims.length * truckDims.width * truckDims.height;
            return (usedVolume / totalVolume) * 100;
        }
        
        function boxesIntersect(x1, y1, z1, l1, h1, w1, x2, y2, z2, l2, h2, w2) {
            return !(x1 + l1 <= x2 || x2 + l2 <= x1 ||
                    y1 + h1 <= y2 || y2 + h2 <= y1 ||
                    z1 + w1 <= z2 || z2 + w2 <= z1);
        }
        
        function isPointInsideBox(point, packedBoxes) {
            for (const box of packedBoxes) {
                if (point.x >= box.position.x && point.x < box.position.x + box.packedDims.length &&
                    point.y >= box.position.y && point.y < box.position.y + box.packedDims.height &&
                    point.z >= box.position.z && point.z < box.position.z + box.packedDims.width) {
                    return true;
                }
            }
            return false;
        }
        
        function createBoxMesh(box) {
            const config = TRUCK_CONFIGS[currentTruckType];
            const wheelR = config.wheelRadius * SCALE;
            const floorHeight = wheelR * 1.3 + 0.04;
            
            const l = box.packedDims.length * SCALE;
            const h = box.packedDims.height * SCALE;
            const w = box.packedDims.width * SCALE;
            
            // Cardboard box material
            const boxMaterial = new THREE.MeshStandardMaterial({
                color: box.color,
                roughness: 0.8,
                metalness: 0.0
            });
            
            const geometry = new THREE.BoxGeometry(l * 0.98, h * 0.98, w * 0.98);
            const mesh = new THREE.Mesh(geometry, boxMaterial);
            
            // Position relative to cargo floor
            const cargoL = truckDims.length * SCALE;
            const cargoW = truckDims.width * SCALE;
            
            mesh.position.set(
                box.position.x * SCALE + l/2 - cargoL/2,
                floorHeight + box.position.y * SCALE + h/2,
                box.position.z * SCALE + w/2 - cargoW/2
            );
            
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            // Add edges for cardboard look
            const edges = new THREE.EdgesGeometry(geometry);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x5D4037, linewidth: 1 });
            const wireframe = new THREE.LineSegments(edges, lineMaterial);
            mesh.add(wireframe);
            
            // Add tape effect on top
            const tapeGeo = new THREE.BoxGeometry(l * 0.15, 0.01, w * 0.98);
            const tapeMaterial = new THREE.MeshStandardMaterial({ color: 0xD2B48C });
            const tape = new THREE.Mesh(tapeGeo, tapeMaterial);
            tape.position.y = h/2;
            mesh.add(tape);
            
            // Fragile sticker
            if (box.fragile) {
                const stickerGeo = new THREE.PlaneGeometry(l * 0.4, h * 0.3);
                const stickerMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xFF0000,
                    side: THREE.DoubleSide
                });
                const sticker = new THREE.Mesh(stickerGeo, stickerMaterial);
                sticker.rotation.y = Math.PI / 2;
                sticker.position.x = l/2 + 0.001;
                mesh.add(sticker);
            }
            
            scene.add(mesh);
            packedMeshes.push(mesh);
        }
        
        // Human-realistic animated loading with LIFO optimization
        // Workers enter through rear doors, walk to position, place box
        // Last delivery items go to front first, first delivery items near doors
        async function animatePacking() {
            clearPackedBoxes();
            
            if (boxes.length === 0) {
                updateStatus('No packages to load!');
                return;
            }
            
            // Open doors if closed
            if (!doorsOpen) {
                toggleDoors();
                await sleep(600);
            }
            
            boxes.forEach(b => { b.packed = false; b.position = null; });
            
            // LIFO: Higher sequence = later delivery = load first = goes to front
            const sortedBoxes = [...boxes].sort((a, b) => {
                if (b.sequence !== a.sequence) return b.sequence - a.sequence;
                const volA = a.length * a.width * a.height;
                const volB = b.length * b.width * b.height;
                return volB - volA;
            });
            
            // Start from front of truck (workers can reach front when empty)
            let extremePoints = [
                { x: truckDims.length - 1, y: 0, z: 0 },
                { x: truckDims.length - 1, y: 0, z: truckDims.width - 1 }
            ];
            const packedBoxes = [];
            
            for (let i = 0; i < sortedBoxes.length; i++) {
                const box = sortedBoxes[i];
                updateStatus(`Worker loading package ${i + 1}/${sortedBoxes.length} (Delivery #${box.sequence})...`);
                
                const placement = findBestPlacement(box, extremePoints, packedBoxes);
                
                if (placement) {
                    box.packed = true;
                    box.position = { x: placement.x, y: placement.y, z: placement.z };
                    box.packedDims = { 
                        length: placement.dims.l, 
                        width: placement.dims.w, 
                        height: placement.dims.h 
                    };
                    box.rotated = placement.rotated;
                    packedBoxes.push(box);
                    
                    // Update extreme points after placing box
                    extremePoints = updateExtremePoints(extremePoints, box, packedBoxes);
                    
                    // Animate: box enters from rear, worker carries it to position
                    await animateHumanLoading(box);
                    
                    updateStats();
                    updateBoxList();
                }
                
                await sleep(100);
            }
            
            const utilization = calculateUtilization(packedBoxes);
            updateStatus(`Loaded ${packedBoxes.length}/${boxes.length} (${utilization.toFixed(1)}% volume used)`);
            
            // Close doors after loading
            await sleep(500);
            if (doorsOpen) {
                toggleDoors();
            }
        }
        
        // Realistic animation: box enters through rear doors, moves horizontally to position
        // If stacking, box slides in low then lifts up
        function animateHumanLoading(box) {
            return new Promise(resolve => {
                const config = TRUCK_CONFIGS[currentTruckType];
                const wheelR = config.wheelRadius * SCALE;
                const floorHeight = wheelR * 1.3 + 0.04;
                
                const l = box.packedDims.length * SCALE;
                const h = box.packedDims.height * SCALE;
                const w = box.packedDims.width * SCALE;
                
                const boxMaterial = new THREE.MeshStandardMaterial({
                    color: box.color,
                    roughness: 0.8,
                    metalness: 0.0
                });
                
                const geometry = new THREE.BoxGeometry(l * 0.98, h * 0.98, w * 0.98);
                const mesh = new THREE.Mesh(geometry, boxMaterial);
                
                const cargoL = truckDims.length * SCALE;
                const cargoW = truckDims.width * SCALE;
                
                // Final position in the truck
                const targetX = box.position.x * SCALE + l/2 - cargoL/2;
                const targetY = floorHeight + box.position.y * SCALE + h/2;
                const targetZ = box.position.z * SCALE + w/2 - cargoW/2;
                
                // Start position: outside the truck at rear door level (worker carrying box)
                const startX = -cargoL/2 - 1.5; // Behind the truck (at the doors)
                const carryHeight = floorHeight + h/2 + 0.3; // Worker holds box at waist height
                
                mesh.position.set(startX, carryHeight, targetZ);
                
                // Add cardboard details
                const edges = new THREE.EdgesGeometry(geometry);
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0x5D4037 });
                const wireframe = new THREE.LineSegments(edges, lineMaterial);
                mesh.add(wireframe);
                
                const tapeGeo = new THREE.BoxGeometry(l * 0.15, 0.01, w * 0.98);
                const tapeMaterial = new THREE.MeshStandardMaterial({ color: 0xD2B48C });
                const tape = new THREE.Mesh(tapeGeo, tapeMaterial);
                tape.position.y = h/2;
                mesh.add(tape);
                
                if (box.fragile) {
                    const stickerGeo = new THREE.PlaneGeometry(l * 0.4, h * 0.3);
                    const stickerMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xFF0000,
                        side: THREE.DoubleSide
                    });
                    const sticker = new THREE.Mesh(stickerGeo, stickerMaterial);
                    sticker.rotation.y = Math.PI / 2;
                    sticker.position.x = l/2 + 0.001;
                    mesh.add(sticker);
                }
                
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                
                scene.add(mesh);
                packedMeshes.push(mesh);
                
                // Animation phases:
                // 1. Enter truck through rear doors (move from outside to inside)
                // 2. Walk to the position (move along X axis)
                // 3. Place/stack the box (lower to final Y position)
                
                const phase1Duration = 300; // Enter truck
                const phase2Duration = 400; // Walk to position
                const phase3Duration = 250; // Place box
                const totalDuration = phase1Duration + phase2Duration + phase3Duration;
                
                const startTime = Date.now();
                
                // Intermediate point: just inside the truck doors
                const entryX = -cargoL/2 + 0.3;
                
                function animateMove() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / totalDuration, 1);
                    
                    if (elapsed < phase1Duration) {
                        // Phase 1: Enter through doors
                        const p = elapsed / phase1Duration;
                        const eased = 1 - Math.pow(1 - p, 2);
                        mesh.position.x = startX + (entryX - startX) * eased;
                        mesh.position.y = carryHeight;
                    } else if (elapsed < phase1Duration + phase2Duration) {
                        // Phase 2: Walk to position (horizontal movement)
                        const p = (elapsed - phase1Duration) / phase2Duration;
                        const eased = p; // Linear for walking
                        mesh.position.x = entryX + (targetX - entryX) * eased;
                        mesh.position.y = carryHeight;
                    } else {
                        // Phase 3: Place the box (lower to final position)
                        const p = (elapsed - phase1Duration - phase2Duration) / phase3Duration;
                        const eased = 1 - Math.pow(1 - p, 2);
                        mesh.position.x = targetX;
                        mesh.position.y = carryHeight + (targetY - carryHeight) * eased;
                    }
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateMove);
                    } else {
                        mesh.position.set(targetX, targetY, targetZ);
                        resolve();
                    }
                }
                
                animateMove();
            });
        }
        
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        function clearPackedBoxes() {
            for (const mesh of packedMeshes) {
                scene.remove(mesh);
            }
            packedMeshes = [];
            boxes.forEach(b => { b.packed = false; b.position = null; });
        }
        
        function clearAll() {
            clearPackedBoxes();
            boxes = [];
            boxIdCounter = 0;
            updateBoxList();
            updateStats();
            updateStatus('All packages cleared');
        }
        
        function resetCamera() {
            const config = TRUCK_CONFIGS[currentTruckType];
            const cargoL = truckDims.length * SCALE;
            const distance = Math.max(12, cargoL * 1.5);
            
            camera.position.set(distance, distance * 0.6, distance);
            camera.lookAt(0, 1, 0);
            controls.target.set(0, 1, 0);
            controls.update();
        }
        
        function updateStats() {
            const config = TRUCK_CONFIGS[currentTruckType];
            const packedCount = boxes.filter(b => b.packed).length;
            const usedVolume = boxes.filter(b => b.packed)
                .reduce((sum, b) => sum + b.length * b.width * b.height, 0);
            const totalVolume = truckDims.length * truckDims.width * truckDims.height;
            const usedWeight = boxes.filter(b => b.packed)
                .reduce((sum, b) => sum + b.weight, 0);
            
            document.getElementById('stat-boxes').textContent = boxes.length;
            document.getElementById('stat-packed').textContent = packedCount;
            document.getElementById('stat-volume').textContent = 
                ((usedVolume / totalVolume) * 100).toFixed(1) + '%';
            document.getElementById('stat-weight').textContent = 
                `${usedWeight} / ${maxWeight} kg`;
            document.getElementById('progress-fill').style.width = 
                ((usedVolume / totalVolume) * 100) + '%';
        }
        
        function updateBoxList() {
            const list = document.getElementById('box-list');
            list.innerHTML = boxes.map(box => `
                <div class="box-item">
                    <div class="box-color" style="background-color: #${box.color.toString(16).padStart(6, '0')}"></div>
                    <div class="box-info">
                        <div>üì¶ #${box.id} ${box.packed ? '‚úÖ' : '‚è≥'} ${box.fragile ? '‚ö†Ô∏è' : ''}</div>
                        <div class="box-dims">${box.length}√ó${box.width}√ó${box.height}cm, ${box.weight}kg, Seq: ${box.sequence}</div>
                    </div>
                </div>
            `).join('');
        }
        
        function updateStatus(message) {
            document.getElementById('loading-status').textContent = message;
        }
        
        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        window.onload = init;
    </script>
</body>
</html>
