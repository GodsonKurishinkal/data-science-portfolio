<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Truck Loading Optimization | ML-Powered Bin Packing - Supply Chain Portfolio</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        :root {
            /* Apple/Google inspired color palette */
            --bg-primary: #000000;
            --bg-secondary: #1c1c1e;
            --bg-tertiary: #2c2c2e;
            --bg-elevated: #3a3a3c;
            --text-primary: #ffffff;
            --text-secondary: rgba(255, 255, 255, 0.7);
            --text-tertiary: rgba(255, 255, 255, 0.5);
            --accent-blue: #0a84ff;
            --accent-green: #30d158;
            --accent-orange: #ff9f0a;
            --accent-red: #ff453a;
            --accent-purple: #bf5af2;
            --accent-teal: #64d2ff;
            --border-color: rgba(255, 255, 255, 0.1);
            --shadow-color: rgba(0, 0, 0, 0.3);
            --glass-bg: rgba(28, 28, 30, 0.8);
            --glass-border: rgba(255, 255, 255, 0.08);
            --transition-fast: 0.15s ease;
            --transition-medium: 0.25s ease;
            --transition-slow: 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
            --radius-xl: 20px;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        #container {
            display: flex;
            height: 100vh;
            height: 100dvh;
            width: 100%;
        }
        
        /* ============================================================
           SIDEBAR - Premium Glass Design
           ============================================================ */
        #sidebar {
            width: 380px;
            min-width: 380px;
            background: var(--glass-bg);
            backdrop-filter: blur(40px) saturate(180%);
            -webkit-backdrop-filter: blur(40px) saturate(180%);
            padding: 24px;
            overflow-y: auto;
            border-right: 1px solid var(--glass-border);
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 10;
        }
        
        #sidebar::-webkit-scrollbar {
            width: 6px;
        }
        
        #sidebar::-webkit-scrollbar-track {
            background: transparent;
        }
        
        #sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }
        
        #sidebar::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        #canvas-container {
            flex: 1;
            position: relative;
        }
        
        #canvas-container canvas {
            display: block;
        }
        
        /* ============================================================
           TYPOGRAPHY
           ============================================================ */
        .header-section {
            margin-bottom: 20px;
        }
        
        h1 {
            font-size: 1.5rem;
            font-weight: 700;
            letter-spacing: -0.02em;
            margin-bottom: 6px;
            background: linear-gradient(135deg, var(--text-primary) 0%, var(--text-secondary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .subtitle {
            font-size: 0.8rem;
            font-weight: 400;
            color: var(--text-tertiary);
            line-height: 1.5;
        }
        
        /* Section Cards */
        .section-card {
            background: var(--bg-secondary);
            border-radius: var(--radius-lg);
            padding: 16px;
            margin-bottom: 12px;
            border: 1px solid var(--glass-border);
            transition: all var(--transition-medium);
        }
        
        .section-card:hover {
            border-color: rgba(255, 255, 255, 0.15);
        }
        
        .section-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 14px;
        }
        
        .section-icon {
            width: 32px;
            height: 32px;
            border-radius: var(--radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
        }
        
        .section-icon.blue { background: rgba(10, 132, 255, 0.15); }
        .section-icon.green { background: rgba(48, 209, 88, 0.15); }
        .section-icon.orange { background: rgba(255, 159, 10, 0.15); }
        .section-icon.purple { background: rgba(191, 90, 242, 0.15); }
        .section-icon.red { background: rgba(255, 69, 58, 0.15); }
        .section-icon.teal { background: rgba(100, 210, 255, 0.15); }
        
        .section-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-primary);
            letter-spacing: -0.01em;
        }
        
        /* ============================================================
           FORM CONTROLS
           ============================================================ */
        .control-group {
            margin-bottom: 12px;
        }
        
        label {
            display: block;
            font-size: 0.75rem;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }
        
        input[type="number"], select {
            width: 100%;
            padding: 12px 14px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-family: inherit;
            font-size: 0.95rem;
            font-weight: 500;
            transition: all var(--transition-fast);
            -webkit-appearance: none;
            appearance: none;
        }
        
        input[type="number"]:hover, select:hover {
            border-color: rgba(255, 255, 255, 0.2);
        }
        
        input[type="number"]:focus, select:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px rgba(10, 132, 255, 0.2);
        }
        
        select {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23ffffff' fill-opacity='0.5' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 14px center;
            padding-right: 40px;
            cursor: pointer;
        }
        
        .dimension-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
        }
        
        .dimension-inputs .control-group {
            margin-bottom: 0;
        }
        
        .dimension-inputs input {
            text-align: center;
            padding: 12px 8px;
        }
        
        /* Custom Checkbox */
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 0;
        }
        
        .checkbox-group input[type="checkbox"] {
            -webkit-appearance: none;
            appearance: none;
            width: 22px;
            height: 22px;
            border: 2px solid var(--border-color);
            border-radius: 6px;
            background: var(--bg-tertiary);
            cursor: pointer;
            position: relative;
            transition: all var(--transition-fast);
        }
        
        .checkbox-group input[type="checkbox"]:checked {
            background: var(--accent-orange);
            border-color: var(--accent-orange);
        }
        
        .checkbox-group input[type="checkbox"]:checked::after {
            content: '‚úì';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 14px;
            font-weight: 700;
        }
        
        .checkbox-group label {
            margin-bottom: 0;
            text-transform: none;
            font-size: 0.9rem;
            cursor: pointer;
        }
        
        /* ============================================================
           BUTTONS - Apple Style
           ============================================================ */
        .button-row {
            display: flex;
            gap: 8px;
            margin-top: 4px;
        }
        
        button {
            flex: 1;
            padding: 12px 16px;
            border: none;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-family: inherit;
            font-size: 0.85rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            transition: all var(--transition-fast);
            position: relative;
            overflow: hidden;
        }
        
        button:active {
            transform: scale(0.98);
        }
        
        .btn-primary {
            background: var(--accent-blue);
            color: white;
        }
        
        .btn-primary:hover {
            background: #0977e6;
            box-shadow: 0 4px 16px rgba(10, 132, 255, 0.3);
        }
        
        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }
        
        .btn-secondary:hover {
            background: var(--bg-elevated);
            border-color: rgba(255, 255, 255, 0.2);
        }
        
        .btn-success {
            background: var(--accent-green);
            color: white;
        }
        
        .btn-success:hover {
            background: #28b84d;
            box-shadow: 0 4px 16px rgba(48, 209, 88, 0.3);
        }
        
        .btn-danger {
            background: var(--accent-red);
            color: white;
        }
        
        .btn-danger:hover {
            background: #e63e35;
            box-shadow: 0 4px 16px rgba(255, 69, 58, 0.3);
        }
        
        .btn-icon-only {
            width: 44px;
            height: 44px;
            flex: none;
            padding: 0;
            font-size: 1.1rem;
        }
        
        /* ============================================================
           STATS & METRICS
           ============================================================ */
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .stat-item {
            background: var(--bg-tertiary);
            border-radius: var(--radius-md);
            padding: 12px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 2px;
        }
        
        .stat-value.blue { color: var(--accent-blue); }
        .stat-value.green { color: var(--accent-green); }
        .stat-value.orange { color: var(--accent-orange); }
        .stat-value.purple { color: var(--accent-purple); }
        
        .stat-label {
            font-size: 0.7rem;
            font-weight: 500;
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }
        
        /* Progress/Utilization Bars */
        .metric-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .metric-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }
        
        .metric-value {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background: var(--bg-tertiary);
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 12px;
        }
        
        .progress-fill {
            height: 100%;
            border-radius: 3px;
            transition: width var(--transition-medium);
        }
        
        .progress-fill.blue { background: linear-gradient(90deg, var(--accent-blue), #5eb3ff); }
        .progress-fill.green { background: linear-gradient(90deg, var(--accent-green), #7ae99a); }
        .progress-fill.orange { background: linear-gradient(90deg, var(--accent-orange), #ffbf4d); }
        .progress-fill.purple { background: linear-gradient(90deg, var(--accent-purple), #d98aff); }
        .progress-fill.teal { background: linear-gradient(90deg, var(--accent-teal), #99e5ff); }
        
        /* Quality Score Badge */
        .quality-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            border-radius: var(--radius-xl);
            font-size: 0.85rem;
            font-weight: 600;
            margin-top: 8px;
        }
        
        .quality-badge.excellent {
            background: rgba(48, 209, 88, 0.15);
            color: var(--accent-green);
        }
        
        .quality-badge.good {
            background: rgba(10, 132, 255, 0.15);
            color: var(--accent-blue);
        }
        
        .quality-badge.average {
            background: rgba(255, 159, 10, 0.15);
            color: var(--accent-orange);
        }
        
        .quality-badge.poor {
            background: rgba(255, 69, 58, 0.15);
            color: var(--accent-red);
        }
        
        /* Zone Legend Pills */
        .zone-pills {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        
        .zone-pill {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            background: var(--bg-tertiary);
            border-radius: var(--radius-xl);
            font-size: 0.75rem;
            font-weight: 500;
            color: var(--text-secondary);
        }
        
        .zone-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }
        
        /* Package List */
        .package-list {
            max-height: 180px;
            overflow-y: auto;
            margin-top: 8px;
        }
        
        .package-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            background: var(--bg-tertiary);
            border-radius: var(--radius-md);
            margin-bottom: 6px;
            transition: all var(--transition-fast);
        }
        
        .package-item:hover {
            background: var(--bg-elevated);
        }
        
        .package-color {
            width: 36px;
            height: 36px;
            border-radius: var(--radius-sm);
            flex-shrink: 0;
        }
        
        .package-details {
            flex: 1;
            min-width: 0;
        }
        
        .package-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .package-meta {
            font-size: 0.75rem;
            color: var(--text-tertiary);
            margin-top: 2px;
        }
        
        .badge {
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.65rem;
            font-weight: 700;
            text-transform: uppercase;
        }
        
        .badge-fragile {
            background: rgba(255, 69, 58, 0.2);
            color: var(--accent-red);
        }
        
        .badge-packed {
            background: rgba(48, 209, 88, 0.2);
            color: var(--accent-green);
        }
        
        .badge-pending {
            background: rgba(255, 159, 10, 0.2);
            color: var(--accent-orange);
        }
        
        /* ============================================================
           CANVAS OVERLAYS
           ============================================================ */
        #info-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            padding: 14px 18px;
            border-radius: var(--radius-lg);
            border: 1px solid var(--glass-border);
            font-size: 0.8rem;
            color: var(--text-secondary);
            line-height: 1.6;
            box-shadow: 0 8px 32px var(--shadow-color);
        }
        
        #info-overlay strong {
            color: var(--text-primary);
            font-weight: 600;
        }
        
        #loading-status {
            position: absolute;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            padding: 12px 24px;
            border-radius: var(--radius-xl);
            border: 1px solid var(--glass-border);
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--text-primary);
            box-shadow: 0 8px 32px var(--shadow-color);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent-green);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* Algorithm Info Card */
        .algo-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 8px;
        }
        
        .algo-item {
            padding: 8px 10px;
            background: var(--bg-tertiary);
            border-radius: var(--radius-sm);
            font-size: 0.7rem;
        }
        
        .algo-item-label {
            color: var(--text-tertiary);
            margin-bottom: 2px;
        }
        
        .algo-item-value {
            color: var(--text-primary);
            font-weight: 600;
        }
        
        /* Desktop/Mobile visibility */
        .mobile-only { display: none; }
        .desktop-only { display: inline; }
        
        /* ============================================================
           MOBILE TOGGLE BUTTON (FAB)
           ============================================================ */
        .mobile-toggle {
            display: none;
            position: fixed;
            bottom: 24px;
            right: 24px;
            z-index: 1000;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: var(--accent-blue);
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 6px 24px rgba(10, 132, 255, 0.4);
            transition: all var(--transition-medium);
        }
        
        .mobile-toggle:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 32px rgba(10, 132, 255, 0.5);
        }
        
        .mobile-toggle:active {
            transform: scale(0.95);
        }
        
        .mobile-close {
            display: none;
            position: absolute;
            top: 16px;
            right: 16px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            font-size: 20px;
            cursor: pointer;
            z-index: 1001;
            transition: all var(--transition-fast);
        }
        
        .mobile-close:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }
        
        /* ============================================================
           MOBILE RESPONSIVE STYLES
           ============================================================ */
        @media (max-width: 768px) {
            body {
                overflow-x: hidden;
            }
            
            #container {
                flex-direction: column;
            }
            
            #sidebar {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                min-width: 0;
                height: 100%;
                z-index: 999;
                transform: translateX(-100%);
                transition: transform var(--transition-slow);
                padding: 20px;
                padding-top: 60px;
                border-right: none;
            }
            
            #sidebar.open {
                transform: translateX(0);
            }
            
            #canvas-container {
                width: 100%;
                height: 100%;
                min-height: 100vh;
                min-height: 100dvh;
            }
            
            .mobile-toggle {
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            .mobile-close {
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            .mobile-only { display: inline; }
            .desktop-only { display: none; }
            
            h1 {
                font-size: 1.3rem;
            }
            
            .section-card {
                padding: 14px;
            }
            
            input[type="number"], select {
                font-size: 16px;
                padding: 14px;
            }
            
            button {
                padding: 14px 16px;
            }
            
            #info-overlay {
                top: 12px;
                left: 12px;
                padding: 10px 14px;
                font-size: 0.7rem;
                max-width: 200px;
            }
            
            #loading-status {
                bottom: 100px;
                padding: 10px 20px;
                font-size: 0.8rem;
            }
            
            .stats-grid {
                grid-template-columns: 1fr 1fr;
            }
            
            .package-list {
                max-height: 140px;
            }
        }
        
        /* Small phones */
        @media (max-width: 380px) {
            #sidebar {
                padding: 16px;
                padding-top: 56px;
            }
            
            h1 {
                font-size: 1.2rem;
            }
            
            .section-card {
                padding: 12px;
            }
            
            .dimension-inputs {
                gap: 6px;
            }
        }
        
        /* Tablet */
        @media (min-width: 769px) and (max-width: 1024px) {
            #sidebar {
                width: 340px;
            }
        }
        
        /* Large screens */
        @media (min-width: 1400px) {
            #sidebar {
                width: 420px;
            }
            
            h1 {
                font-size: 1.7rem;
            }
        }
    </style>
</head>
<body>
    <!-- Mobile Toggle Button (FAB) -->
    <button class="mobile-toggle" onclick="toggleSidebar()" aria-label="Open controls">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M12 5v14M5 12h14"/>
        </svg>
    </button>
    
    <div id="container">
        <div id="sidebar">
            <!-- Mobile Close Button -->
            <button class="mobile-close" onclick="toggleSidebar()" aria-label="Close controls">‚úï</button>
            
            <!-- Header -->
            <div class="header-section">
                <h1>Load Optimization</h1>
                <p class="subtitle">ML-Powered 3D Bin Packing with Extreme Points Algorithm</p>
            </div>
            
            <!-- Truck Configuration -->
            <div class="section-card">
                <div class="section-header">
                    <div class="section-icon blue">üöõ</div>
                    <span class="section-title">Vehicle Configuration</span>
                </div>
                <div class="control-group">
                    <label>Truck Type</label>
                    <select id="truck-type" onchange="changeTruckType()">
                        <option value="small_van">Small Van (300√ó150√ó180 cm)</option>
                        <option value="medium_truck">Medium Truck (450√ó200√ó220 cm)</option>
                        <option value="large_truck" selected>Large Truck (600√ó250√ó270 cm)</option>
                        <option value="semi_trailer">Semi Trailer (1350√ó250√ó280 cm)</option>
                    </select>
                </div>
                <button class="btn-secondary" onclick="toggleDoors()" style="width: 100%; margin-top: 8px;">
                    üö™ Toggle Doors
                </button>
            </div>
            
            <!-- Package Input -->
            <div class="section-card">
                <div class="section-header">
                    <div class="section-icon orange">üì¶</div>
                    <span class="section-title">Add Package</span>
                </div>
                <label>Dimensions (cm)</label>
                <div class="dimension-inputs">
                    <div class="control-group">
                        <input type="number" id="box-length" value="50" min="10" max="200" inputmode="numeric" placeholder="L">
                    </div>
                    <div class="control-group">
                        <input type="number" id="box-width" value="40" min="10" max="200" inputmode="numeric" placeholder="W">
                    </div>
                    <div class="control-group">
                        <input type="number" id="box-height" value="30" min="10" max="200" inputmode="numeric" placeholder="H">
                    </div>
                </div>
                <div class="control-group">
                    <label>Weight (kg)</label>
                    <input type="number" id="box-weight" value="10" min="1" max="500" inputmode="numeric">
                </div>
                <div class="control-group">
                    <label>Delivery Sequence</label>
                    <input type="number" id="box-sequence" value="1" min="1" max="100" inputmode="numeric" placeholder="1 = First Stop">
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="box-fragile">
                    <label for="box-fragile">Fragile Item</label>
                </div>
                <div class="button-row">
                    <button class="btn-primary" onclick="addBox()">Add</button>
                    <button class="btn-secondary" onclick="addRandomBoxes()">+10 Random</button>
                </div>
            </div>
            
            <!-- Controls -->
            <div class="section-card">
                <div class="section-header">
                    <div class="section-icon green">‚ñ∂Ô∏è</div>
                    <span class="section-title">Optimization Controls</span>
                </div>
                <div class="button-row">
                    <button class="btn-success" onclick="runPacking(); closeSidebarOnMobile();">Run Packing</button>
                    <button class="btn-primary" onclick="animatePacking(); closeSidebarOnMobile();">Animate</button>
                </div>
                <div class="button-row" style="margin-top: 8px;">
                    <button class="btn-secondary" onclick="resetCamera()">Reset View</button>
                    <button class="btn-danger" onclick="clearAll()">Clear All</button>
                </div>
            </div>
            
            <!-- Statistics -->
            <div class="section-card">
                <div class="section-header">
                    <div class="section-icon purple">üìä</div>
                    <span class="section-title">Performance Metrics</span>
                </div>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value blue" id="stat-boxes">0</div>
                        <div class="stat-label">Packages</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value green" id="stat-packed">0</div>
                        <div class="stat-label">Packed</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value orange" id="stat-volume">0%</div>
                        <div class="stat-label">Volume</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value purple" id="stat-weight-pct">0%</div>
                        <div class="stat-label">Weight</div>
                    </div>
                </div>
                
                <div style="margin-top: 12px;">
                    <div class="metric-row">
                        <span class="metric-label">Volume Utilization</span>
                        <span class="metric-value" id="util-volume">0%</span>
                    </div>
                    <div class="progress-bar"><div class="progress-fill blue" id="util-volume-bar" style="width: 0%"></div></div>
                    
                    <div class="metric-row">
                        <span class="metric-label">Floor Coverage</span>
                        <span class="metric-value" id="util-floor">0%</span>
                    </div>
                    <div class="progress-bar"><div class="progress-fill green" id="util-floor-bar" style="width: 0%"></div></div>
                    
                    <div class="metric-row">
                        <span class="metric-label">Weight Capacity</span>
                        <span class="metric-value" id="util-weight">0%</span>
                    </div>
                    <div class="progress-bar"><div class="progress-fill orange" id="util-weight-bar" style="width: 0%"></div></div>
                    
                    <div class="metric-row">
                        <span class="metric-label">Stability Index</span>
                        <span class="metric-value" id="util-stability">‚Äî</span>
                    </div>
                    <div class="progress-bar"><div class="progress-fill purple" id="util-stability-bar" style="width: 0%"></div></div>
                </div>
                
                <div id="quality-badge-container"></div>
            </div>
            
            <!-- Algorithm Info -->
            <div class="section-card">
                <div class="section-header">
                    <div class="section-icon teal">üß†</div>
                    <span class="section-title">Algorithm Details</span>
                </div>
                <div class="algo-info">
                    <div class="algo-item">
                        <div class="algo-item-label">Method</div>
                        <div class="algo-item-value">Extreme Points</div>
                    </div>
                    <div class="algo-item">
                        <div class="algo-item-label">Heuristic</div>
                        <div class="algo-item-value">Best-Fit Decreasing</div>
                    </div>
                    <div class="algo-item">
                        <div class="algo-item-label">Complexity</div>
                        <div class="algo-item-value">O(n¬≤ √ó 6)</div>
                    </div>
                    <div class="algo-item">
                        <div class="algo-item-label">Constraints</div>
                        <div class="algo-item-value">LIFO + Stability</div>
                    </div>
                </div>
            </div>
            
            <!-- Delivery Zones -->
            <div class="section-card">
                <div class="section-header">
                    <div class="section-icon red">üó∫Ô∏è</div>
                    <span class="section-title">Delivery Zones</span>
                </div>
                <div class="zone-pills" id="zone-legend">
                    <div class="zone-pill"><div class="zone-dot" style="background: #30d158"></div>Zone 1</div>
                    <div class="zone-pill"><div class="zone-dot" style="background: #64d2ff"></div>Zone 2</div>
                    <div class="zone-pill"><div class="zone-dot" style="background: #ff9f0a"></div>Zone 3</div>
                    <div class="zone-pill"><div class="zone-dot" style="background: #ff453a"></div>Zone 4</div>
                    <div class="zone-pill"><div class="zone-dot" style="background: #bf5af2"></div>Zone 5</div>
                </div>
            </div>
            
            <!-- Package List -->
            <div class="section-card">
                <div class="section-header">
                    <div class="section-icon blue">üìã</div>
                    <span class="section-title">Package Queue</span>
                </div>
                <div class="package-list" id="box-list">
                    <div style="text-align: center; color: var(--text-tertiary); padding: 20px; font-size: 0.85rem;">
                        No packages added yet
                    </div>
                </div>
            </div>
        </div>
        
        <div id="canvas-container">
            <div id="info-overlay">
                <strong>Controls:</strong><br>
                <span class="desktop-only">üñ±Ô∏è Left drag: Orbit | Right drag: Pan | Scroll: Zoom</span>
                <span class="mobile-only">üëÜ One finger: Rotate | üëå Two fingers: Zoom/Pan</span>
                <br>
                <em style="font-size: 0.8em; color: rgba(255,255,255,0.5);">
                Extreme Points + BFD Algorithm
                </em>
            </div>
            <div id="loading-status"><div class="status-dot"></div>Ready to optimize</div>
        </div>
    </div>

    <script>
        // ============================================================
        // MOBILE RESPONSIVE FUNCTIONS
        // ============================================================
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('open');
        }
        
        function closeSidebarOnMobile() {
            if (window.innerWidth <= 768) {
                const sidebar = document.getElementById('sidebar');
                sidebar.classList.remove('open');
            }
        }
        
        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', function(event) {
            if (window.innerWidth <= 768) {
                const sidebar = document.getElementById('sidebar');
                const toggle = document.querySelector('.mobile-toggle');
                if (!sidebar.contains(event.target) && 
                    !toggle.contains(event.target) && 
                    sidebar.classList.contains('open')) {
                    sidebar.classList.remove('open');
                }
            }
        });
        
        // Global variables
        let scene, camera, renderer, controls;
        let truckGroup;
        let cargoFloor;
        let leftDoor, rightDoor;
        let doorsOpen = true;
        let boxes = [];
        let packedMeshes = [];
        let boxIdCounter = 0;
        
        // Truck configurations
        const TRUCK_CONFIGS = {
            small_van: {
                name: 'Small Van',
                cargo: { length: 300, width: 150, height: 180 },
                maxWeight: 1000,
                cabLength: 120,
                wheelRadius: 35,
                color: 0x2196F3,
                isVan: true
            },
            medium_truck: {
                name: 'Medium Truck',
                cargo: { length: 450, width: 200, height: 220 },
                maxWeight: 3000,
                cabLength: 150,
                wheelRadius: 45,
                color: 0xFF9800
            },
            large_truck: {
                name: 'Large Truck',
                cargo: { length: 600, width: 250, height: 270 },
                maxWeight: 5000,
                cabLength: 180,
                wheelRadius: 50,
                color: 0xE53935
            },
            semi_trailer: {
                name: 'Semi Trailer',
                cargo: { length: 1350, width: 250, height: 280 },
                maxWeight: 25000,
                cabLength: 200,
                wheelRadius: 55,
                color: 0x1565C0,
                isTrailer: true
            }
        };
        
        let currentTruckType = 'large_truck';
        let truckDims = { ...TRUCK_CONFIGS.large_truck.cargo };
        let maxWeight = TRUCK_CONFIGS.large_truck.maxWeight;
        
        const SCALE = 0.01;
        
        // Color palette for boxes (cardboard colors)
        const BOX_COLORS = [
            0x8D6E63, 0xA1887F, 0xBCAAA4, 0x795548,
            0xD7CCC8, 0x6D4C41, 0x5D4037, 0x4E342E,
            0xFFCC80, 0xFFE0B2, 0xFFB74D, 0xFFA726
        ];
        
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue
            
            // Add fog for depth
            scene.fog = new THREE.Fog(0x87CEEB, 20, 100);
            
            const container = document.getElementById('canvas-container');
            camera = new THREE.PerspectiveCamera(
                50,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            camera.position.set(12, 6, 12);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Optimize for mobile
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 3; // Allow closer zoom on mobile
            controls.maxDistance = 50;
            controls.maxPolarAngle = Math.PI / 2;
            controls.enablePan = true;
            controls.touches = {
                ONE: THREE.TOUCH.ROTATE,
                TWO: THREE.TOUCH.DOLLY_PAN
            };
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
            sunLight.position.set(20, 30, 20);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 100;
            sunLight.shadow.camera.left = -20;
            sunLight.shadow.camera.right = 20;
            sunLight.shadow.camera.top = 20;
            sunLight.shadow.camera.bottom = -20;
            scene.add(sunLight);
            
            // Ground
            createGround();
            
            // Create truck
            createTruck();
            
            window.addEventListener('resize', onWindowResize);
            animate();
        }
        
        function createGround() {
            // Asphalt ground
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x3a3a3a,
                roughness: 0.9,
                metalness: 0.1
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.01;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Road markings
            const lineGeometry = new THREE.PlaneGeometry(0.15, 50);
            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
            
            for (let i = -2; i <= 2; i++) {
                const line = new THREE.Mesh(lineGeometry, lineMaterial);
                line.rotation.x = -Math.PI / 2;
                line.position.set(i * 3, 0.01, 0);
                scene.add(line);
            }
            
            // Warehouse floor area
            const warehouseGeometry = new THREE.PlaneGeometry(15, 20);
            const warehouseMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x606060,
                roughness: 0.7
            });
            const warehouse = new THREE.Mesh(warehouseGeometry, warehouseMaterial);
            warehouse.rotation.x = -Math.PI / 2;
            warehouse.position.set(-12, 0.02, 0);
            warehouse.receiveShadow = true;
            scene.add(warehouse);
        }
        
        function createTruck() {
            if (truckGroup) {
                scene.remove(truckGroup);
            }
            
            truckGroup = new THREE.Group();
            const config = TRUCK_CONFIGS[currentTruckType];
            
            const cargoL = truckDims.length * SCALE;
            const cargoW = truckDims.width * SCALE;
            const cargoH = truckDims.height * SCALE;
            const cabL = config.cabLength * SCALE;
            const wheelR = config.wheelRadius * SCALE;
            const floorHeight = wheelR * 1.3;
            
            // Materials
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: config.color,
                roughness: 0.3,
                metalness: 0.6
            });
            
            const whiteMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xF5F5F5,
                roughness: 0.4,
                metalness: 0.2
            });
            
            const darkMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a1a,
                roughness: 0.8
            });
            
            const glassMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x87CEEB,
                transparent: true,
                opacity: 0.6,
                roughness: 0.1,
                metalness: 0.9
            });
            
            const cargoMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xEEEEEE,
                roughness: 0.5,
                metalness: 0.3
            });
            
            // === CARGO BOX ===
            const cargoGroup = new THREE.Group();
            
            // Cargo floor
            const floorThickness = 0.08;
            const floorGeo = new THREE.BoxGeometry(cargoL, floorThickness, cargoW);
            cargoFloor = new THREE.Mesh(floorGeo, darkMaterial);
            cargoFloor.position.set(cargoL/2, floorHeight, cargoW/2);
            cargoFloor.castShadow = true;
            cargoFloor.receiveShadow = true;
            cargoGroup.add(cargoFloor);
            
            // Cargo walls
            const wallThickness = 0.05;
            
            // Left wall
            const leftWallGeo = new THREE.BoxGeometry(cargoL, cargoH, wallThickness);
            const leftWall = new THREE.Mesh(leftWallGeo, cargoMaterial);
            leftWall.position.set(cargoL/2, floorHeight + cargoH/2, wallThickness/2);
            leftWall.castShadow = true;
            cargoGroup.add(leftWall);
            
            // Right wall
            const rightWall = new THREE.Mesh(leftWallGeo, cargoMaterial);
            rightWall.position.set(cargoL/2, floorHeight + cargoH/2, cargoW - wallThickness/2);
            rightWall.castShadow = true;
            cargoGroup.add(rightWall);
            
            // Front wall (behind cab)
            const frontWallGeo = new THREE.BoxGeometry(wallThickness, cargoH, cargoW);
            const frontWall = new THREE.Mesh(frontWallGeo, cargoMaterial);
            frontWall.position.set(cargoL - wallThickness/2, floorHeight + cargoH/2, cargoW/2);
            frontWall.castShadow = true;
            cargoGroup.add(frontWall);
            
            // Roof
            const roofGeo = new THREE.BoxGeometry(cargoL, wallThickness, cargoW);
            const roof = new THREE.Mesh(roofGeo, cargoMaterial);
            roof.position.set(cargoL/2, floorHeight + cargoH, cargoW/2);
            roof.castShadow = true;
            cargoGroup.add(roof);
            
            // === REAR DOORS ===
            // Doors swing outward from hinges at the outer edges of the truck
            const doorWidth = (cargoW - wallThickness * 2) / 2;
            const doorGeo = new THREE.BoxGeometry(wallThickness * 2, cargoH * 0.95, doorWidth);
            
            // Left door - hinge is at z=0 (left edge of truck)
            leftDoor = new THREE.Group();
            const leftDoorMesh = new THREE.Mesh(doorGeo, cargoMaterial);
            // Position door mesh so pivot point is at the hinge (outer edge)
            leftDoorMesh.position.set(wallThickness, 0, doorWidth/2);
            leftDoor.add(leftDoorMesh);
            
            // Door handle left (on the inner edge, near center of truck)
            const handleGeo = new THREE.BoxGeometry(0.08, 0.3, 0.05);
            const leftHandle = new THREE.Mesh(handleGeo, darkMaterial);
            leftHandle.position.set(wallThickness * 2 + 0.02, 0, doorWidth - 0.15);
            leftDoor.add(leftHandle);
            
            // Position left door group at the hinge point (left outer edge at rear)
            leftDoor.position.set(0, floorHeight + cargoH/2, 0);
            cargoGroup.add(leftDoor);
            
            // Right door - hinge is at z=cargoW (right edge of truck)
            rightDoor = new THREE.Group();
            const rightDoorMesh = new THREE.Mesh(doorGeo, cargoMaterial);
            // Position door mesh so pivot point is at the hinge (outer edge)
            rightDoorMesh.position.set(wallThickness, 0, -doorWidth/2);
            rightDoor.add(rightDoorMesh);
            
            // Door handle right (on the inner edge, near center of truck)
            const rightHandle = new THREE.Mesh(handleGeo, darkMaterial);
            rightHandle.position.set(wallThickness * 2 + 0.02, 0, -doorWidth + 0.15);
            rightDoor.add(rightHandle);
            
            // Position right door group at the hinge point (right outer edge at rear)
            rightDoor.position.set(0, floorHeight + cargoH/2, cargoW);
            cargoGroup.add(rightDoor);
            
            // Open doors by default - swing outward from hinges
            leftDoor.rotation.y = Math.PI / 2;  // Left door opens to the left
            rightDoor.rotation.y = -Math.PI / 2; // Right door opens to the right
            
            // === CAB ===
            const cabGroup = new THREE.Group();
            const cabHeight = cargoH * 0.85;
            const cabWidth = cargoW * 0.95;
            
            // Cab body
            const cabGeo = new THREE.BoxGeometry(cabL, cabHeight, cabWidth);
            const cab = new THREE.Mesh(cabGeo, bodyMaterial);
            cab.position.set(cargoL + cabL/2 + 0.1, floorHeight + cabHeight/2, cargoW/2);
            cab.castShadow = true;
            cabGroup.add(cab);
            
            // Cab roof (slightly curved effect with box)
            const cabRoofGeo = new THREE.BoxGeometry(cabL * 0.9, 0.1, cabWidth * 0.9);
            const cabRoof = new THREE.Mesh(cabRoofGeo, bodyMaterial);
            cabRoof.position.set(cargoL + cabL/2 + 0.1, floorHeight + cabHeight + 0.05, cargoW/2);
            cabRoof.castShadow = true;
            cabGroup.add(cabRoof);
            
            // Windshield
            const windshieldGeo = new THREE.BoxGeometry(0.05, cabHeight * 0.5, cabWidth * 0.8);
            const windshield = new THREE.Mesh(windshieldGeo, glassMaterial);
            windshield.position.set(cargoL + cabL + 0.1, floorHeight + cabHeight * 0.65, cargoW/2);
            cabGroup.add(windshield);
            
            // Side windows
            const sideWindowGeo = new THREE.BoxGeometry(cabL * 0.4, cabHeight * 0.35, 0.05);
            const leftWindow = new THREE.Mesh(sideWindowGeo, glassMaterial);
            leftWindow.position.set(cargoL + cabL * 0.7, floorHeight + cabHeight * 0.6, cargoW/2 - cabWidth/2);
            cabGroup.add(leftWindow);
            
            const rightWindow = new THREE.Mesh(sideWindowGeo, glassMaterial);
            rightWindow.position.set(cargoL + cabL * 0.7, floorHeight + cabHeight * 0.6, cargoW/2 + cabWidth/2);
            cabGroup.add(rightWindow);
            
            // Headlights
            const headlightGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.05, 16);
            const headlightMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFFFCC,
                emissive: 0xFFFF00,
                emissiveIntensity: 0.3
            });
            
            const leftHeadlight = new THREE.Mesh(headlightGeo, headlightMaterial);
            leftHeadlight.rotation.z = Math.PI / 2;
            leftHeadlight.position.set(cargoL + cabL + 0.12, floorHeight + cabHeight * 0.3, cargoW/2 - cabWidth * 0.35);
            cabGroup.add(leftHeadlight);
            
            const rightHeadlight = new THREE.Mesh(headlightGeo, headlightMaterial);
            rightHeadlight.rotation.z = Math.PI / 2;
            rightHeadlight.position.set(cargoL + cabL + 0.12, floorHeight + cabHeight * 0.3, cargoW/2 + cabWidth * 0.35);
            cabGroup.add(rightHeadlight);
            
            // Grille
            const grilleGeo = new THREE.BoxGeometry(0.05, cabHeight * 0.25, cabWidth * 0.5);
            const grille = new THREE.Mesh(grilleGeo, darkMaterial);
            grille.position.set(cargoL + cabL + 0.1, floorHeight + cabHeight * 0.35, cargoW/2);
            cabGroup.add(grille);
            
            // Bumper
            const bumperGeo = new THREE.BoxGeometry(0.15, 0.15, cabWidth);
            const bumper = new THREE.Mesh(bumperGeo, darkMaterial);
            bumper.position.set(cargoL + cabL + 0.15, floorHeight * 0.5, cargoW/2);
            bumper.castShadow = true;
            cabGroup.add(bumper);
            
            // Side mirrors
            const mirrorGeo = new THREE.BoxGeometry(0.1, 0.15, 0.08);
            const leftMirror = new THREE.Mesh(mirrorGeo, darkMaterial);
            leftMirror.position.set(cargoL + cabL * 0.9, floorHeight + cabHeight * 0.7, cargoW/2 - cabWidth/2 - 0.15);
            cabGroup.add(leftMirror);
            
            const rightMirror = new THREE.Mesh(mirrorGeo, darkMaterial);
            rightMirror.position.set(cargoL + cabL * 0.9, floorHeight + cabHeight * 0.7, cargoW/2 + cabWidth/2 + 0.15);
            cabGroup.add(rightMirror);
            
            // === WHEELS ===
            const wheelGroup = new THREE.Group();
            
            function createWheel(x, z) {
                const wheel = new THREE.Group();
                
                // Tire
                const tireGeo = new THREE.CylinderGeometry(wheelR, wheelR, wheelR * 0.4, 24);
                const tire = new THREE.Mesh(tireGeo, new THREE.MeshStandardMaterial({ 
                    color: 0x1a1a1a,
                    roughness: 0.9
                }));
                tire.rotation.x = Math.PI / 2;
                tire.castShadow = true;
                wheel.add(tire);
                
                // Hubcap
                const hubGeo = new THREE.CylinderGeometry(wheelR * 0.5, wheelR * 0.5, wheelR * 0.42, 16);
                const hub = new THREE.Mesh(hubGeo, new THREE.MeshStandardMaterial({ 
                    color: 0xCCCCCC,
                    metalness: 0.8,
                    roughness: 0.2
                }));
                hub.rotation.x = Math.PI / 2;
                wheel.add(hub);
                
                wheel.position.set(x, wheelR, z);
                return wheel;
            }
            
            // Front wheels
            wheelGroup.add(createWheel(cargoL + cabL * 0.7, cargoW/2 - cabWidth/2 - wheelR * 0.2));
            wheelGroup.add(createWheel(cargoL + cabL * 0.7, cargoW/2 + cabWidth/2 + wheelR * 0.2));
            
            // Rear wheels (dual for larger trucks)
            const rearWheelX = cargoL * 0.25;
            wheelGroup.add(createWheel(rearWheelX, cargoW/2 - cargoW/2 - wheelR * 0.2));
            wheelGroup.add(createWheel(rearWheelX, cargoW/2 + cargoW/2 + wheelR * 0.2));
            
            if (currentTruckType === 'large_truck' || currentTruckType === 'semi_trailer') {
                // Second set of rear wheels
                wheelGroup.add(createWheel(rearWheelX - wheelR * 1.2, cargoW/2 - cargoW/2 - wheelR * 0.2));
                wheelGroup.add(createWheel(rearWheelX - wheelR * 1.2, cargoW/2 + cargoW/2 + wheelR * 0.2));
            }
            
            if (currentTruckType === 'semi_trailer') {
                // Additional trailer wheels
                const midWheelX = cargoL * 0.6;
                wheelGroup.add(createWheel(midWheelX, cargoW/2 - cargoW/2 - wheelR * 0.2));
                wheelGroup.add(createWheel(midWheelX, cargoW/2 + cargoW/2 + wheelR * 0.2));
            }
            
            // === CHASSIS ===
            const chassisGeo = new THREE.BoxGeometry(cargoL + cabL + 0.2, 0.15, cargoW * 0.3);
            const chassis = new THREE.Mesh(chassisGeo, darkMaterial);
            chassis.position.set((cargoL + cabL) / 2, wheelR * 0.8, cargoW/2);
            chassis.castShadow = true;
            
            // === TAIL LIGHTS ===
            const tailLightGeo = new THREE.BoxGeometry(0.05, 0.15, 0.1);
            const tailLightMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFF0000,
                emissive: 0x330000,
                emissiveIntensity: 0.5
            });
            
            const leftTailLight = new THREE.Mesh(tailLightGeo, tailLightMaterial);
            leftTailLight.position.set(-0.03, floorHeight + 0.2, wallThickness + 0.1);
            cargoGroup.add(leftTailLight);
            
            const rightTailLight = new THREE.Mesh(tailLightGeo, tailLightMaterial);
            rightTailLight.position.set(-0.03, floorHeight + 0.2, cargoW - wallThickness - 0.1);
            cargoGroup.add(rightTailLight);
            
            // Assemble truck
            truckGroup.add(cargoGroup);
            truckGroup.add(cabGroup);
            truckGroup.add(wheelGroup);
            truckGroup.add(chassis);
            
            // Center the truck
            truckGroup.position.set(-cargoL/2, 0, -cargoW/2);
            
            scene.add(truckGroup);
            
            updateStats();
        }
        
        function toggleDoors() {
            doorsOpen = !doorsOpen;
            
            // Doors swing from hinges at outer edges
            // Open: left door rotates +90¬∞ (opens left), right door rotates -90¬∞ (opens right)
            // Closed: both doors at 0¬∞
            const leftTargetAngle = doorsOpen ? Math.PI / 2 : 0;
            const rightTargetAngle = doorsOpen ? -Math.PI / 2 : 0;
            
            // Animate doors
            const duration = 500;
            const startTime = Date.now();
            const startLeftAngle = leftDoor.rotation.y;
            const startRightAngle = rightDoor.rotation.y;
            
            function animateDoors() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = 1 - Math.pow(1 - progress, 3);
                
                leftDoor.rotation.y = startLeftAngle + (leftTargetAngle - startLeftAngle) * eased;
                rightDoor.rotation.y = startRightAngle + (rightTargetAngle - startRightAngle) * eased;
                
                if (progress < 1) {
                    requestAnimationFrame(animateDoors);
                }
            }
            
            animateDoors();
            updateStatus(doorsOpen ? 'Doors opened' : 'Doors closed');
        }
        
        function changeTruckType() {
            currentTruckType = document.getElementById('truck-type').value;
            const config = TRUCK_CONFIGS[currentTruckType];
            truckDims = { ...config.cargo };
            maxWeight = config.maxWeight;
            
            clearPackedBoxes();
            createTruck();
            resetCamera();
            
            document.getElementById('stat-truck').textContent = config.name;
            document.getElementById('stat-space').textContent = 
                `${truckDims.length}√ó${truckDims.width}√ó${truckDims.height} cm`;
            
            updateStats();
            updateStatus(`Switched to ${config.name}`);
        }
        
        function addBox() {
            const box = {
                id: ++boxIdCounter,
                length: parseInt(document.getElementById('box-length').value),
                width: parseInt(document.getElementById('box-width').value),
                height: parseInt(document.getElementById('box-height').value),
                weight: parseInt(document.getElementById('box-weight').value),
                sequence: parseInt(document.getElementById('box-sequence').value),
                fragile: document.getElementById('box-fragile').checked,
                color: BOX_COLORS[boxIdCounter % BOX_COLORS.length],
                packed: false,
                position: null
            };
            
            boxes.push(box);
            updateBoxList();
            updateStats();
            updateStatus(`Added package #${box.id}`);
        }
        
        function addRandomBoxes() {
            for (let i = 0; i < 10; i++) {
                const box = {
                    id: ++boxIdCounter,
                    length: Math.floor(Math.random() * 60) + 20,
                    width: Math.floor(Math.random() * 50) + 20,
                    height: Math.floor(Math.random() * 40) + 15,
                    weight: Math.floor(Math.random() * 30) + 5,
                    sequence: Math.floor(Math.random() * 10) + 1,
                    fragile: Math.random() > 0.85,
                    color: BOX_COLORS[boxIdCounter % BOX_COLORS.length],
                    packed: false,
                    position: null
                };
                boxes.push(box);
            }
            updateBoxList();
            updateStats();
            updateStatus(`Added 10 packages`);
        }
        
        // ============================================================
        // ADVANCED 3D BIN PACKING ALGORITHM
        // ============================================================
        // Implementation: Extreme Points Heuristic (Crainic et al., 2008)
        // Enhanced with: Best Fit Decreasing (BFD) + Multi-Rotation Search
        // 
        // Key Features:
        // 1. O(n¬≤) placement optimization with 6-axis rotation
        // 2. LIFO (Last-In-First-Out) delivery sequence optimization
        // 3. Multi-constraint satisfaction (weight, fragility, stability)
        // 4. Column-based wall-building for operational efficiency
        // 5. Dynamic floor-first strategy to maximize cube utilization
        //
        // Industry Applications: Amazon FC, FedEx Ground, UPS Worldport
        // ============================================================
        
        function runPacking() {
            clearPackedBoxes();
            
            if (boxes.length === 0) {
                updateStatus('No packages to load!');
                return;
            }
            
            // ============================================================
            // INDUSTRY-STANDARD SORTING (Amazon/FedEx/UPS approach)
            // ============================================================
            // 1. LIFO by delivery sequence (last delivery ‚Üí front, first ‚Üí doors)
            // 2. Within same sequence: HEAVY items first (stable base)
            // 3. FRAGILE items last in each zone (placed on top)
            
            const sortedBoxes = [...boxes].sort((a, b) => {
                // Primary: delivery sequence (higher = later delivery = load first = goes deep)
                if (b.sequence !== a.sequence) return b.sequence - a.sequence;
                
                // Secondary: Fragile items LAST (so they go on top)
                if (a.fragile !== b.fragile) return a.fragile ? 1 : -1;
                
                // Tertiary: HEAVY items first (creates stable base)
                if (Math.abs(b.weight - a.weight) > 5) return b.weight - a.weight;
                
                // Quaternary: Larger volume items first
                const volA = a.length * a.width * a.height;
                const volB = b.length * b.width * b.height;
                return volB - volA;
            });
            
            // Initialize extreme points starting from FRONT of truck (cab side)
            // Workers start at the front when truck is empty
            // Create a grid of floor points to ensure even spreading
            // x = depth (0 = rear doors, max = cab front wall)
            let extremePoints = [];
            
            // Add multiple floor points across the front of the truck
            // This ensures boxes spread across the floor instead of stacking
            const numWidthPoints = Math.ceil(truckDims.width / 30); // ~30cm spacing
            for (let i = 0; i <= numWidthPoints; i++) {
                const z = Math.min(i * 30, truckDims.width - 1);
                extremePoints.push({ x: truckDims.length - 1, y: 0, z: z });
            }
            const packedBoxes = [];
            
            for (const box of sortedBoxes) {
                const placement = findBestPlacement(box, extremePoints, packedBoxes);
                
                if (placement) {
                    box.packed = true;
                    box.position = { x: placement.x, y: placement.y, z: placement.z };
                    box.packedDims = { 
                        length: placement.dims.l, 
                        width: placement.dims.w, 
                        height: placement.dims.h 
                    };
                    box.rotated = placement.rotated;
                    packedBoxes.push(box);
                    
                    // Update extreme points after placing box
                    extremePoints = updateExtremePoints(extremePoints, box, packedBoxes);
                }
            }
            
            for (const box of packedBoxes) {
                createBoxMesh(box);
            }
            
            updateStats();
            updateBoxList();
            
            const utilization = calculateUtilization(packedBoxes);
            const unpackedCount = boxes.length - packedBoxes.length;
            if (unpackedCount > 0) {
                updateStatus(`‚ö†Ô∏è Optimization complete: ${packedBoxes.length}/${boxes.length} items loaded (${utilization.toFixed(1)}% cube util) - ${unpackedCount} items could not fit`);
            } else {
                updateStatus(`‚úÖ Optimization complete: ${packedBoxes.length} items loaded | ${utilization.toFixed(1)}% cube utilization`);
            }
        }
        
        // Find the best placement for a box using Extreme Points algorithm
        // For LIFO: positions box so it fits against the front or existing boxes
        function findBestPlacement(box, extremePoints, packedBoxes) {
            let bestPlacement = null;
            let bestScore = -Infinity;
            
            // Try all 6 possible orientations of the box
            const orientations = getBoxOrientations(box);
            
            for (const ep of extremePoints) {
                for (const dims of orientations) {
                    // For front-to-back loading, adjust X so box fits within bounds
                    // The extreme point is where the box's back edge should be
                    // So the box extends from ep.x to ep.x + dims.l
                    // But if ep is near front wall, we need to push box back
                    let adjustedX = ep.x;
                    if (adjustedX + dims.l > truckDims.length) {
                        adjustedX = truckDims.length - dims.l;
                    }
                    
                    const adjustedPos = { x: adjustedX, y: ep.y, z: ep.z };
                    
                    if (canPlaceBoxAt(adjustedPos, dims.l, dims.w, dims.h, packedBoxes)) {
                        const score = calculatePlacementScore(adjustedPos, dims, packedBoxes, box);
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestPlacement = {
                                x: adjustedPos.x,
                                y: adjustedPos.y,
                                z: adjustedPos.z,
                                dims: dims,
                                rotated: dims.rotated
                            };
                        }
                    }
                }
            }
            
            return bestPlacement;
        }
        
        // Get all 6 possible orientations of a box
        function getBoxOrientations(box) {
            const l = box.length, w = box.width, h = box.height;
            
            // For human loading, we typically keep boxes upright
            // But allow rotation in the horizontal plane
            // Also allow laying flat if it helps
            return [
                { l: l, w: w, h: h, rotated: false },   // Original
                { l: w, w: l, h: h, rotated: true },    // Rotated 90¬∞ horizontal
                { l: l, w: h, h: w, rotated: 'side1' }, // On side
                { l: h, w: l, h: w, rotated: 'side2' }, // On side rotated
                { l: w, w: h, h: l, rotated: 'flat1' }, // Flat
                { l: h, w: w, h: l, rotated: 'flat2' }  // Flat rotated
            ];
        }
        
        // Calculate a score for placing a box at a given position
        // SMART LOADING: Only stack when floor space is limited
        // LIFO DELIVERY OPTIMIZATION: Load last-delivery items first (deepest in truck)
        // INDUSTRY BEST PRACTICES: Weight distribution + Fragile handling
        function calculatePlacementScore(pos, dims, packedBoxes, currentBox = null) {
            let score = 0;
            
            // COLUMN-BASED LOADING (build walls from FRONT to BACK for LIFO)
            const columnDepth = 80;
            const currentColumn = Math.floor(pos.x / columnDepth);
            const maxColumn = Math.floor(truckDims.length / columnDepth);
            
            // ============================================================
            // SMART STACKING: Calculate overall floor utilization first
            // Only encourage stacking when floor is getting full
            // ============================================================
            const totalFloorArea = truckDims.length * truckDims.width;
            let usedFloorArea = 0;
            for (const box of packedBoxes) {
                if (box.position.y < 5) { // Floor level
                    usedFloorArea += box.packedDims.length * box.packedDims.width;
                }
            }
            const floorUtilization = usedFloorArea / totalFloorArea;
            
            // Calculate remaining items volume to see if we need to stack
            const remainingBoxes = boxes.filter(b => !b.packed);
            const remainingVolume = remainingBoxes.reduce((sum, b) => 
                sum + b.length * b.width * b.height, 0);
            const truckVolume = truckDims.length * truckDims.width * truckDims.height;
            const projectedUtilization = (usedFloorArea * 50 + remainingVolume) / truckVolume; // Rough estimate
            
            // 1. PREFER FRONT (high X) columns first - this is LIFO loading!
            score += currentColumn * 100000;
            
            // 2. Check if current front column is filled before moving back
            if (currentColumn < maxColumn) {
                for (let c = maxColumn; c > currentColumn; c--) {
                    const frontColFill = getColumnFillRatio(c, columnDepth, packedBoxes);
                    if (frontColFill < 0.5) {
                        score -= 30000;
                        break;
                    }
                }
            }
            
            // ============================================================
            // SMART FLOOR-FIRST STRATEGY
            // Strong preference for floor until it's well-utilized
            // ============================================================
            if (pos.y < 1) {
                // Floor placement - always good!
                score += 80000; // VERY strong floor bonus
                
                // Extra bonus when floor has space - MUCH stronger!
                if (floorUtilization < 0.4) {
                    score += 100000; // Floor mostly empty - MUST use floor!
                } else if (floorUtilization < 0.6) {
                    score += 60000; // Still plenty of floor space
                } else if (floorUtilization < 0.8) {
                    score += 30000; // Some floor space left
                }
            } else {
                // STACKING - only when necessary
                // VERY heavily penalize stacking when floor has room
                if (floorUtilization < 0.4) {
                    score -= 200000; // EXTREME penalty - floor is mostly empty! DO NOT STACK!
                } else if (floorUtilization < 0.6) {
                    score -= 100000; // Very strong penalty - lots of floor space!
                } else if (floorUtilization < 0.75) {
                    score -= 50000; // Strong penalty - still floor space available
                } else if (floorUtilization < 0.9) {
                    score -= 15000; // Small penalty - floor getting full
                } else {
                    // Floor is >90% full, stacking is acceptable
                    score += 10000;
                }
                
                // Limit stack height - avoid tall towers
                const stackHeight = pos.y + dims.h;
                const maxReasonableHeight = truckDims.height * 0.6; // Don't go above 60% height unless needed
                
                if (floorUtilization < 0.8 && stackHeight > maxReasonableHeight) {
                    score -= 50000; // Penalize tall stacks when floor has room
                }
            }
            
            // 3. WEIGHT DISTRIBUTION (Industry Best Practice)
            if (currentBox) {
                if (currentBox.weight > 25) {
                    // Heavy items: STRONG preference for floor
                    if (pos.y < 1) {
                        score += 25000;
                    } else {
                        score -= 30000; // Even stronger penalty for heavy stacking
                    }
                } else if (currentBox.weight < 10 && floorUtilization > 0.7) {
                    // Light items: OK to stack ONLY when floor is getting full
                    if (pos.y > 0) score += 5000;
                }
                
                // 4. FRAGILE ITEM HANDLING (Amazon/FedEx standard)
                if (currentBox.fragile) {
                    if (pos.y > 0 && floorUtilization > 0.6) {
                        // Fragile on top is good when floor is filling up
                        score += 30000;
                    } else if (pos.y < 1) {
                        // Fragile on floor is fine if floor has space
                        const roomAbove = truckDims.height - (pos.y + dims.h);
                        if (roomAbove > 30 && floorUtilization > 0.7) {
                            score -= 15000; // Only penalize if floor is getting full
                        }
                    }
                    
                    // Never place fragile under heavy boxes
                    for (const packed of packedBoxes) {
                        if (packed.weight > 20 && 
                            pos.y + dims.h <= packed.position.y + 2 &&
                            pos.y + dims.h >= packed.position.y - 2) {
                            score -= 50000;
                        }
                    }
                }
            }
            
            // 5. Stacking safety checks
            if (pos.y > 0) {
                // Check what we're stacking on - never stack on fragile!
                for (const packed of packedBoxes) {
                    const packedTop = packed.position.y + packed.packedDims.height;
                    if (Math.abs(packedTop - pos.y) < 2) {
                        if (packed.fragile) {
                            score -= 100000; // NEVER stack on fragile items!
                        }
                    }
                }
                
                // Direct support bonus (still important for stability)
                const directSupport = getDirectSupportScore(pos, dims, packedBoxes);
                score += directSupport * 1000;
            }
            
            // 6. Within column, fill left to right
            score -= (pos.z / truckDims.width) * 100;
            
            // 7. Contact scoring (snug fit is good)
            const contactScore = calculateContactScore(pos, dims, packedBoxes);
            score += contactScore * 500;
            
            // 8. Gap penalty
            const gapPenalty = calculateGapPenalty(pos, dims, packedBoxes);
            score -= gapPenalty * 200;
            
            // 9. Prefer upright orientation
            if (dims.rotated === false) score += 20;
            else if (dims.rotated === true) score += 15;
            
            return score;
        }
        
        // Calculate how filled a column is (floor coverage ratio)
        function getColumnFillRatio(columnIndex, columnDepth, packedBoxes) {
            const columnStartX = columnIndex * columnDepth;
            const columnEndX = Math.min((columnIndex + 1) * columnDepth, truckDims.length);
            const columnArea = (columnEndX - columnStartX) * truckDims.width;
            
            let floorCoverage = 0;
            for (const box of packedBoxes) {
                if (box.position.y < 5) { // Floor level boxes only
                    const overlapX = Math.max(0,
                        Math.min(box.position.x + box.packedDims.length, columnEndX) -
                        Math.max(box.position.x, columnStartX)
                    );
                    if (overlapX > 0) {
                        floorCoverage += overlapX * box.packedDims.width;
                    }
                }
            }
            
            return floorCoverage / columnArea;
        }
        
        // Get the current active loading column (the one workers are filling)
        function getActiveColumn(packedBoxes, columnDepth) {
            // Find the furthest column that has any boxes
            let activeColumn = 0;
            for (const box of packedBoxes) {
                const boxColumn = Math.floor(box.position.x / columnDepth);
                activeColumn = Math.max(activeColumn, boxColumn);
            }
            return activeColumn;
        }
        
        // Calculate how well a position is directly supported by boxes below
        function getDirectSupportScore(pos, dims, packedBoxes) {
            let supportScore = 0;
            const l = dims.l, w = dims.w;
            const boxArea = l * w;
            
            for (const packed of packedBoxes) {
                const packedTop = packed.position.y + packed.packedDims.height;
                // Check if this box is directly below (within 2cm)
                if (Math.abs(packedTop - pos.y) < 2) {
                    const overlapX = Math.max(0, 
                        Math.min(pos.x + l, packed.position.x + packed.packedDims.length) -
                        Math.max(pos.x, packed.position.x)
                    );
                    const overlapZ = Math.max(0,
                        Math.min(pos.z + w, packed.position.z + packed.packedDims.width) -
                        Math.max(pos.z, packed.position.z)
                    );
                    const overlapArea = overlapX * overlapZ;
                    
                    // Bonus for centered support (box sitting squarely on another)
                    if (overlapArea / boxArea > 0.7) {
                        supportScore += 1.0;
                    } else if (overlapArea / boxArea > 0.5) {
                        supportScore += 0.5;
                    }
                }
            }
            return supportScore;
        }
        
        // Calculate how much contact area the box has with walls and other boxes
        function calculateContactScore(pos, dims, packedBoxes) {
            let contactArea = 0;
            const l = dims.l, w = dims.w, h = dims.h;
            
            // Contact with floor
            if (pos.y === 0) {
                contactArea += l * w;
            }
            
            // Contact with front wall (cab side)
            if (pos.x + l >= truckDims.length - 1) {
                contactArea += w * h;
            }
            
            // Contact with left wall
            if (pos.z === 0) {
                contactArea += l * h;
            }
            
            // Contact with right wall
            if (pos.z + w >= truckDims.width - 1) {
                contactArea += l * h;
            }
            
            // Contact with other boxes
            for (const packed of packedBoxes) {
                const p = packed.position;
                const d = packed.packedDims;
                
                // Check bottom contact (sitting on top of another box)
                if (Math.abs(pos.y - (p.y + d.height)) < 1) {
                    const overlapL = Math.max(0, Math.min(pos.x + l, p.x + d.length) - Math.max(pos.x, p.x));
                    const overlapW = Math.max(0, Math.min(pos.z + w, p.z + d.width) - Math.max(pos.z, p.z));
                    contactArea += overlapL * overlapW * 1.5; // Bonus for stacking
                }
                
                // Check side contacts
                // Right side of new box touching left side of packed box
                if (Math.abs((pos.z + w) - p.z) < 1) {
                    const overlapL = Math.max(0, Math.min(pos.x + l, p.x + d.length) - Math.max(pos.x, p.x));
                    const overlapH = Math.max(0, Math.min(pos.y + h, p.y + d.height) - Math.max(pos.y, p.y));
                    contactArea += overlapL * overlapH * 0.5;
                }
                // Left side touching right side
                if (Math.abs(pos.z - (p.z + d.width)) < 1) {
                    const overlapL = Math.max(0, Math.min(pos.x + l, p.x + d.length) - Math.max(pos.x, p.x));
                    const overlapH = Math.max(0, Math.min(pos.y + h, p.y + d.height) - Math.max(pos.y, p.y));
                    contactArea += overlapL * overlapH * 0.5;
                }
                // Front/back contacts
                if (Math.abs((pos.x + l) - p.x) < 1) {
                    const overlapW = Math.max(0, Math.min(pos.z + w, p.z + d.width) - Math.max(pos.z, p.z));
                    const overlapH = Math.max(0, Math.min(pos.y + h, p.y + d.height) - Math.max(pos.y, p.y));
                    contactArea += overlapW * overlapH * 0.5;
                }
                if (Math.abs(pos.x - (p.x + d.length)) < 1) {
                    const overlapW = Math.max(0, Math.min(pos.z + w, p.z + d.width) - Math.max(pos.z, p.z));
                    const overlapH = Math.max(0, Math.min(pos.y + h, p.y + d.height) - Math.max(pos.y, p.y));
                    contactArea += overlapW * overlapH * 0.5;
                }
            }
            
            // Normalize by box surface area
            const totalSurface = 2 * (l * w + l * h + w * h);
            return contactArea / totalSurface;
        }
        
        // Calculate penalty for creating hard-to-fill gaps
        function calculateGapPenalty(pos, dims, packedBoxes) {
            let penalty = 0;
            const l = dims.l, w = dims.w, h = dims.h;
            
            // Check for small gaps that would be hard to fill
            const minUsableGap = 15; // 15cm minimum useful gap
            
            // Gap to left wall
            if (pos.z > 0 && pos.z < minUsableGap) {
                penalty += pos.z / minUsableGap;
            }
            
            // Gap to right wall  
            const rightGap = truckDims.width - (pos.z + w);
            if (rightGap > 0 && rightGap < minUsableGap) {
                penalty += rightGap / minUsableGap;
            }
            
            // Gap to front (cab)
            const frontGap = truckDims.length - (pos.x + l);
            if (frontGap > 0 && frontGap < minUsableGap) {
                penalty += frontGap / minUsableGap;
            }
            
            // Gap above (ceiling)
            const topGap = truckDims.height - (pos.y + h);
            if (topGap > 0 && topGap < minUsableGap) {
                penalty += topGap / minUsableGap * 0.5; // Less important
            }
            
            return penalty;
        }
        
        // Check if a box can be placed at a given position
        function canPlaceBoxAt(pos, length, width, height, packedBoxes) {
            // Check bounds
            if (pos.x < 0 || pos.y < 0 || pos.z < 0) return false;
            if (pos.x + length > truckDims.length) return false;
            if (pos.y + height > truckDims.height) return false;
            if (pos.z + width > truckDims.width) return false;
            
            // Check collision with existing boxes
            for (const packed of packedBoxes) {
                if (boxesIntersect(
                    pos.x, pos.y, pos.z, length, height, width,
                    packed.position.x, packed.position.y, packed.position.z,
                    packed.packedDims.length, packed.packedDims.height, packed.packedDims.width
                )) {
                    return false;
                }
            }
            
            // Check support (must be on floor or have adequate support from below)
            if (pos.y > 0.5) {
                let supportArea = 0;
                const boxArea = length * width;
                let supportingBoxes = [];
                
                for (const packed of packedBoxes) {
                    const packedTop = packed.position.y + packed.packedDims.height;
                    if (Math.abs(packedTop - pos.y) < 2) {
                        const overlapX = Math.max(0, 
                            Math.min(pos.x + length, packed.position.x + packed.packedDims.length) -
                            Math.max(pos.x, packed.position.x)
                        );
                        const overlapZ = Math.max(0,
                            Math.min(pos.z + width, packed.position.z + packed.packedDims.width) -
                            Math.max(pos.z, packed.position.z)
                        );
                        if (overlapX > 0 && overlapZ > 0) {
                            supportArea += overlapX * overlapZ;
                            supportingBoxes.push({ box: packed, overlapX, overlapZ });
                        }
                    }
                }
                
                // Need at least 60% support for stability (increased from 50%)
                if (supportArea / boxArea < 0.6) return false;
                
                // Additional stability check: center of mass should be over support
                // The box's center should be within the support area
                const boxCenterX = pos.x + length / 2;
                const boxCenterZ = pos.z + width / 2;
                
                let centerSupported = false;
                for (const support of supportingBoxes) {
                    const sp = support.box.position;
                    const sd = support.box.packedDims;
                    if (boxCenterX >= sp.x && boxCenterX <= sp.x + sd.length &&
                        boxCenterZ >= sp.z && boxCenterZ <= sp.z + sd.width) {
                        centerSupported = true;
                        break;
                    }
                }
                
                // If center isn't over any single box, need even more support
                if (!centerSupported && supportArea / boxArea < 0.75) return false;
            }
            
            return true;
        }
        
        // Update extreme points after placing a box
        // SMART FLOOR-FIRST: Prioritize floor positions, only add stacking points when floor is filling up
        function updateExtremePoints(currentPoints, placedBox, packedBoxes) {
            const pos = placedBox.position;
            const dims = placedBox.packedDims;
            
            // Calculate floor utilization to decide if we should add stacking points
            const totalFloorArea = truckDims.length * truckDims.width;
            let usedFloorArea = 0;
            for (const box of packedBoxes) {
                if (box.position.y < 5) {
                    usedFloorArea += box.packedDims.length * box.packedDims.width;
                }
            }
            const floorUtilization = usedFloorArea / totalFloorArea;
            
            // Generate new extreme points - PRIORITIZE FLOOR POSITIONS
            const newPoints = [];
            
            // ALWAYS add MANY floor-level points (high priority)
            // This ensures we spread across the floor before stacking
            
            // Point toward doors at floor level (back of this box)
            if (pos.x > 0) {
                newPoints.push({ x: pos.x - dims.length, y: 0, z: pos.z });
                newPoints.push({ x: pos.x - dims.length, y: 0, z: pos.z + dims.width / 2 });
                newPoints.push({ x: pos.x - dims.length, y: 0, z: pos.z + dims.width });
            }
            
            // Floor points next to the box (spread sideways!)
            newPoints.push({ x: pos.x, y: 0, z: pos.z + dims.width });
            newPoints.push({ x: pos.x, y: 0, z: pos.z + dims.width + 10 }); // Extra gap for spreading
            
            // Floor point at same depth on opposite side
            if (pos.z > 0) {
                newPoints.push({ x: pos.x, y: 0, z: pos.z - 10 }); // Spread to other side
            }
            
            // Add points toward the doors
            newPoints.push({ x: pos.x - dims.length - 10, y: 0, z: pos.z }); // Floor toward doors
            
            // Add stacking points ONLY when floor is getting VERY full (>75% utilized)
            // This ensures we spread across floor first!
            if (floorUtilization > 0.75) {
                // Point on top of placed box (for stacking)
                newPoints.push({ x: pos.x, y: pos.y + dims.height, z: pos.z });
                newPoints.push({ x: pos.x, y: pos.y + dims.height, z: pos.z + dims.width });
            }
            
            // If floor is really full (>90%), add more stacking options
            if (floorUtilization > 0.9) {
                newPoints.push({ x: pos.x - 1, y: pos.y, z: pos.z });
                newPoints.push({ x: pos.x, y: pos.y, z: pos.z + dims.width });
            }
            
            // Combine with existing points
            let allPoints = [...currentPoints, ...newPoints];
            
            // Remove points that are now inside boxes
            allPoints = allPoints.filter(p => !isPointInsideAnyBox(p, packedBoxes));
            
            // Remove points outside truck bounds
            allPoints = allPoints.filter(p => 
                p.x >= 0 && p.x <= truckDims.length &&
                p.y >= 0 && p.y < truckDims.height &&
                p.z >= 0 && p.z <= truckDims.width
            );
            
            // Remove duplicate points
            const uniquePoints = [];
            const seen = new Set();
            for (const p of allPoints) {
                const key = `${Math.round(p.x)},${Math.round(p.y)},${Math.round(p.z)}`;
                if (!seen.has(key)) {
                    seen.add(key);
                    uniquePoints.push(p);
                }
            }
            
            // Sort by priority: FLOOR FIRST (low y), then FRONT (high x), then LEFT (low z)
            // This ensures we fill the floor before stacking!
            uniquePoints.sort((a, b) => {
                // PRIMARY: lower Y = floor first (CHANGED - floor is now top priority!)
                if (Math.abs(a.y - b.y) > 5) return a.y - b.y;
                // Secondary: higher X = front of truck
                if (Math.abs(b.x - a.x) > 5) return b.x - a.x;
                // Tertiary: lower Z = left side first
                return a.z - b.z;
            });
            
            return uniquePoints;
        }
        
        // Check if a point is inside any packed box
        function isPointInsideAnyBox(point, packedBoxes) {
            for (const box of packedBoxes) {
                const p = box.position;
                const d = box.packedDims;
                if (point.x >= p.x && point.x < p.x + d.length &&
                    point.y >= p.y && point.y < p.y + d.height &&
                    point.z >= p.z && point.z < p.z + d.width) {
                    return true;
                }
            }
            return false;
        }
        
        // Calculate volume utilization percentage
        function calculateUtilization(packedBoxes) {
            const usedVolume = packedBoxes.reduce((sum, b) => 
                sum + b.packedDims.length * b.packedDims.width * b.packedDims.height, 0);
            const totalVolume = truckDims.length * truckDims.width * truckDims.height;
            return (usedVolume / totalVolume) * 100;
        }
        
        function boxesIntersect(x1, y1, z1, l1, h1, w1, x2, y2, z2, l2, h2, w2) {
            return !(x1 + l1 <= x2 || x2 + l2 <= x1 ||
                    y1 + h1 <= y2 || y2 + h2 <= y1 ||
                    z1 + w1 <= z2 || z2 + w2 <= z1);
        }
        
        function isPointInsideBox(point, packedBoxes) {
            for (const box of packedBoxes) {
                if (point.x >= box.position.x && point.x < box.position.x + box.packedDims.length &&
                    point.y >= box.position.y && point.y < box.position.y + box.packedDims.height &&
                    point.z >= box.position.z && point.z < box.position.z + box.packedDims.width) {
                    return true;
                }
            }
            return false;
        }
        
        function createBoxMesh(box) {
            const config = TRUCK_CONFIGS[currentTruckType];
            const wheelR = config.wheelRadius * SCALE;
            const floorHeight = wheelR * 1.3 + 0.04;
            
            const l = box.packedDims.length * SCALE;
            const h = box.packedDims.height * SCALE;
            const w = box.packedDims.width * SCALE;
            
            // Get zone color for delivery sequence visualization
            const zoneColorHex = getZoneColor(box.sequence);
            const zoneColor = parseInt(zoneColorHex.replace('#', ''), 16);
            
            // Cardboard box material with zone-tinted color
            // Blend box color with zone color for visual identification
            const boxMaterial = new THREE.MeshStandardMaterial({
                color: box.color,
                roughness: 0.8,
                metalness: 0.0
            });
            
            const geometry = new THREE.BoxGeometry(l * 0.98, h * 0.98, w * 0.98);
            const mesh = new THREE.Mesh(geometry, boxMaterial);
            
            // Position relative to cargo floor
            const cargoL = truckDims.length * SCALE;
            const cargoW = truckDims.width * SCALE;
            
            mesh.position.set(
                box.position.x * SCALE + l/2 - cargoL/2,
                floorHeight + box.position.y * SCALE + h/2,
                box.position.z * SCALE + w/2 - cargoW/2
            );
            
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            // Add zone-colored edges for delivery sequence visualization
            const edges = new THREE.EdgesGeometry(geometry);
            const lineMaterial = new THREE.LineBasicMaterial({ color: zoneColor, linewidth: 2 });
            const wireframe = new THREE.LineSegments(edges, lineMaterial);
            mesh.add(wireframe);
            
            // Add tape effect on top with zone color
            const tapeGeo = new THREE.BoxGeometry(l * 0.15, 0.015, w * 0.98);
            const tapeMaterial = new THREE.MeshStandardMaterial({ color: zoneColor });
            const tape = new THREE.Mesh(tapeGeo, tapeMaterial);
            tape.position.y = h/2;
            mesh.add(tape);
            
            // Delivery sequence number label on top
            const seqLabelGeo = new THREE.PlaneGeometry(Math.min(l, w) * 0.6, Math.min(l, w) * 0.4);
            const seqLabelMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFFFFF,
                side: THREE.DoubleSide
            });
            const seqLabel = new THREE.Mesh(seqLabelGeo, seqLabelMaterial);
            seqLabel.rotation.x = -Math.PI / 2;
            seqLabel.position.y = h/2 + 0.02;
            mesh.add(seqLabel);
            
            // Zone indicator stripe on side
            const stripeGeo = new THREE.PlaneGeometry(l * 0.98, h * 0.15);
            const stripeMaterial = new THREE.MeshBasicMaterial({ 
                color: zoneColor,
                side: THREE.DoubleSide
            });
            const stripe = new THREE.Mesh(stripeGeo, stripeMaterial);
            stripe.rotation.y = Math.PI / 2;
            stripe.position.set(l/2 + 0.001, -h * 0.35, 0);
            mesh.add(stripe);
            
            // Fragile sticker (larger and more visible)
            if (box.fragile) {
                const stickerGeo = new THREE.PlaneGeometry(l * 0.5, h * 0.35);
                const stickerMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xFF0000,
                    side: THREE.DoubleSide
                });
                const sticker = new THREE.Mesh(stickerGeo, stickerMaterial);
                sticker.rotation.y = Math.PI / 2;
                sticker.position.x = l/2 + 0.002;
                sticker.position.y = h * 0.1;
                mesh.add(sticker);
                
                // Add "‚ö†" symbol backing
                const warningGeo = new THREE.PlaneGeometry(l * 0.25, l * 0.25);
                const warningMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xFFFF00,
                    side: THREE.DoubleSide
                });
                const warning = new THREE.Mesh(warningGeo, warningMaterial);
                warning.rotation.y = Math.PI / 2;
                warning.position.set(l/2 + 0.003, h * 0.1, 0);
                mesh.add(warning);
            }
            
            // Weight indicator (heavy items get a base stripe)
            if (box.weight > 25) {
                const weightGeo = new THREE.PlaneGeometry(l * 0.98, 0.02);
                const weightMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xFF4444,
                    side: THREE.DoubleSide
                });
                const weightStripe = new THREE.Mesh(weightGeo, weightMaterial);
                weightStripe.rotation.x = -Math.PI / 2;
                weightStripe.position.y = -h/2 + 0.01;
                mesh.add(weightStripe);
            }
            
            scene.add(mesh);
            packedMeshes.push(mesh);
        }
        
        // Human-realistic animated loading with LIFO optimization
        // Workers enter through rear doors, walk to position, place box
        // Last delivery items go to front first, first delivery items near doors
        async function animatePacking() {
            clearPackedBoxes();
            
            if (boxes.length === 0) {
                updateStatus('No packages to load!');
                return;
            }
            
            // Open doors if closed
            if (!doorsOpen) {
                toggleDoors();
                await sleep(600);
            }
            
            boxes.forEach(b => { b.packed = false; b.position = null; });
            
            // INDUSTRY-STANDARD SORTING (matching runPacking)
            // LIFO + Weight distribution + Fragile handling
            const sortedBoxes = [...boxes].sort((a, b) => {
                if (b.sequence !== a.sequence) return b.sequence - a.sequence;
                if (a.fragile !== b.fragile) return a.fragile ? 1 : -1;
                if (Math.abs(b.weight - a.weight) > 5) return b.weight - a.weight;
                const volA = a.length * a.width * a.height;
                const volB = b.length * b.width * b.height;
                return volB - volA;
            });
            
            // Start from front of truck (workers can reach front when empty)
            let extremePoints = [
                { x: truckDims.length - 1, y: 0, z: 0 },
                { x: truckDims.length - 1, y: 0, z: truckDims.width - 1 }
            ];
            const packedBoxes = [];
            
            for (let i = 0; i < sortedBoxes.length; i++) {
                const box = sortedBoxes[i];
                updateStatus(`Worker loading package ${i + 1}/${sortedBoxes.length} (Delivery #${box.sequence})...`);
                
                const placement = findBestPlacement(box, extremePoints, packedBoxes);
                
                if (placement) {
                    box.packed = true;
                    box.position = { x: placement.x, y: placement.y, z: placement.z };
                    box.packedDims = { 
                        length: placement.dims.l, 
                        width: placement.dims.w, 
                        height: placement.dims.h 
                    };
                    box.rotated = placement.rotated;
                    packedBoxes.push(box);
                    
                    // Update extreme points after placing box
                    extremePoints = updateExtremePoints(extremePoints, box, packedBoxes);
                    
                    // Animate: box enters from rear, worker carries it to position
                    await animateHumanLoading(box);
                    
                    updateStats();
                    updateBoxList();
                }
                
                await sleep(100);
            }
            
            const utilization = calculateUtilization(packedBoxes);
            updateStatus(`Loaded ${packedBoxes.length}/${boxes.length} (${utilization.toFixed(1)}% volume used)`);
            
            // Close doors after loading
            await sleep(500);
            if (doorsOpen) {
                toggleDoors();
            }
        }
        
        // Realistic animation: box enters through rear doors, moves horizontally to position
        // If stacking, box slides in low then lifts up
        function animateHumanLoading(box) {
            return new Promise(resolve => {
                const config = TRUCK_CONFIGS[currentTruckType];
                const wheelR = config.wheelRadius * SCALE;
                const floorHeight = wheelR * 1.3 + 0.04;
                
                const l = box.packedDims.length * SCALE;
                const h = box.packedDims.height * SCALE;
                const w = box.packedDims.width * SCALE;
                
                const boxMaterial = new THREE.MeshStandardMaterial({
                    color: box.color,
                    roughness: 0.8,
                    metalness: 0.0
                });
                
                const geometry = new THREE.BoxGeometry(l * 0.98, h * 0.98, w * 0.98);
                const mesh = new THREE.Mesh(geometry, boxMaterial);
                
                const cargoL = truckDims.length * SCALE;
                const cargoW = truckDims.width * SCALE;
                
                // Final position in the truck
                const targetX = box.position.x * SCALE + l/2 - cargoL/2;
                const targetY = floorHeight + box.position.y * SCALE + h/2;
                const targetZ = box.position.z * SCALE + w/2 - cargoW/2;
                
                // Start position: outside the truck at rear door level (worker carrying box)
                const startX = -cargoL/2 - 1.5; // Behind the truck (at the doors)
                const carryHeight = floorHeight + h/2 + 0.3; // Worker holds box at waist height
                
                mesh.position.set(startX, carryHeight, targetZ);
                
                // Add cardboard details
                const edges = new THREE.EdgesGeometry(geometry);
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0x5D4037 });
                const wireframe = new THREE.LineSegments(edges, lineMaterial);
                mesh.add(wireframe);
                
                const tapeGeo = new THREE.BoxGeometry(l * 0.15, 0.01, w * 0.98);
                const tapeMaterial = new THREE.MeshStandardMaterial({ color: 0xD2B48C });
                const tape = new THREE.Mesh(tapeGeo, tapeMaterial);
                tape.position.y = h/2;
                mesh.add(tape);
                
                if (box.fragile) {
                    const stickerGeo = new THREE.PlaneGeometry(l * 0.4, h * 0.3);
                    const stickerMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xFF0000,
                        side: THREE.DoubleSide
                    });
                    const sticker = new THREE.Mesh(stickerGeo, stickerMaterial);
                    sticker.rotation.y = Math.PI / 2;
                    sticker.position.x = l/2 + 0.001;
                    mesh.add(sticker);
                }
                
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                
                scene.add(mesh);
                packedMeshes.push(mesh);
                
                // Animation phases:
                // 1. Enter truck through rear doors (move from outside to inside)
                // 2. Walk to the position (move along X axis)
                // 3. Place/stack the box (lower to final Y position)
                
                const phase1Duration = 300; // Enter truck
                const phase2Duration = 400; // Walk to position
                const phase3Duration = 250; // Place box
                const totalDuration = phase1Duration + phase2Duration + phase3Duration;
                
                const startTime = Date.now();
                
                // Intermediate point: just inside the truck doors
                const entryX = -cargoL/2 + 0.3;
                
                function animateMove() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / totalDuration, 1);
                    
                    if (elapsed < phase1Duration) {
                        // Phase 1: Enter through doors
                        const p = elapsed / phase1Duration;
                        const eased = 1 - Math.pow(1 - p, 2);
                        mesh.position.x = startX + (entryX - startX) * eased;
                        mesh.position.y = carryHeight;
                    } else if (elapsed < phase1Duration + phase2Duration) {
                        // Phase 2: Walk to position (horizontal movement)
                        const p = (elapsed - phase1Duration) / phase2Duration;
                        const eased = p; // Linear for walking
                        mesh.position.x = entryX + (targetX - entryX) * eased;
                        mesh.position.y = carryHeight;
                    } else {
                        // Phase 3: Place the box (lower to final position)
                        const p = (elapsed - phase1Duration - phase2Duration) / phase3Duration;
                        const eased = 1 - Math.pow(1 - p, 2);
                        mesh.position.x = targetX;
                        mesh.position.y = carryHeight + (targetY - carryHeight) * eased;
                    }
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateMove);
                    } else {
                        mesh.position.set(targetX, targetY, targetZ);
                        resolve();
                    }
                }
                
                animateMove();
            });
        }
        
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        function clearPackedBoxes() {
            for (const mesh of packedMeshes) {
                scene.remove(mesh);
            }
            packedMeshes = [];
            boxes.forEach(b => { b.packed = false; b.position = null; });
        }
        
        function clearAll() {
            clearPackedBoxes();
            boxes = [];
            boxIdCounter = 0;
            updateBoxList();
            updateStats();
            updateStatus('All packages cleared');
        }
        
        function resetCamera() {
            const config = TRUCK_CONFIGS[currentTruckType];
            const cargoL = truckDims.length * SCALE;
            const distance = Math.max(12, cargoL * 1.5);
            
            camera.position.set(distance, distance * 0.6, distance);
            camera.lookAt(0, 1, 0);
            controls.target.set(0, 1, 0);
            controls.update();
        }
        
        function updateStats() {
            const config = TRUCK_CONFIGS[currentTruckType];
            const packedCount = boxes.filter(b => b.packed).length;
            const packedBoxes = boxes.filter(b => b.packed);
            const usedVolume = packedBoxes
                .reduce((sum, b) => sum + b.length * b.width * b.height, 0);
            const totalVolume = truckDims.length * truckDims.width * truckDims.height;
            const usedWeight = packedBoxes
                .reduce((sum, b) => sum + b.weight, 0);
            
            document.getElementById('stat-boxes').textContent = boxes.length;
            document.getElementById('stat-packed').textContent = packedCount;
            document.getElementById('stat-volume').textContent = 
                ((usedVolume / totalVolume) * 100).toFixed(1) + '%';
            document.getElementById('stat-weight').textContent = 
                `${usedWeight} / ${maxWeight} kg`;
            document.getElementById('progress-fill').style.width = 
                ((usedVolume / totalVolume) * 100) + '%';
            
            // ============================================================
            // CUBE UTILIZATION METRICS (Industry KPIs)
            // Based on Amazon/FedEx/UPS operational standards
            // ============================================================
            const volumeUtil = (usedVolume / totalVolume) * 100;
            const weightUtil = (usedWeight / maxWeight) * 100;
            
            // Calculate floor coverage
            const floorArea = truckDims.length * truckDims.width;
            let floorCoverage = 0;
            for (const box of packedBoxes) {
                if (box.position && box.position.y < 5) { // Floor level
                    floorCoverage += box.packedDims.length * box.packedDims.width;
                }
            }
            const floorUtil = Math.min((floorCoverage / floorArea) * 100, 100);
            
            // ============================================================
            // LOAD STABILITY INDEX (Professional metric)
            // Measures: support coverage, weight distribution, center of mass
            // ============================================================
            let stabilityScore = 100;
            let stackedCount = 0;
            let wellSupportedCount = 0;
            
            for (const box of packedBoxes) {
                if (!box.position) continue;
                
                if (box.position.y > 1) { // Stacked item
                    stackedCount++;
                    // Check support from below
                    let supportArea = 0;
                    const boxArea = box.packedDims.length * box.packedDims.width;
                    
                    for (const other of packedBoxes) {
                        if (!other.position || other === box) continue;
                        const otherTop = other.position.y + other.packedDims.height;
                        
                        if (Math.abs(otherTop - box.position.y) < 3) { // Supporting this box
                            const overlapX = Math.max(0,
                                Math.min(box.position.x + box.packedDims.length, other.position.x + other.packedDims.length) -
                                Math.max(box.position.x, other.position.x));
                            const overlapZ = Math.max(0,
                                Math.min(box.position.z + box.packedDims.width, other.position.z + other.packedDims.width) -
                                Math.max(box.position.z, other.position.z));
                            supportArea += overlapX * overlapZ;
                        }
                    }
                    
                    const supportRatio = supportArea / boxArea;
                    if (supportRatio >= 0.6) wellSupportedCount++;
                    else stabilityScore -= (0.6 - supportRatio) * 30; // Penalty for poor support
                }
                
                // Heavy items high penalty
                if (box.weight > 25 && box.position.y > 50) {
                    stabilityScore -= 10;
                }
            }
            
            // Calculate center of mass deviation
            if (packedBoxes.length > 0) {
                let totalMass = 0, comX = 0, comZ = 0;
                for (const box of packedBoxes) {
                    if (!box.position) continue;
                    const mass = box.weight;
                    comX += (box.position.x + box.packedDims.length / 2) * mass;
                    comZ += (box.position.z + box.packedDims.width / 2) * mass;
                    totalMass += mass;
                }
                if (totalMass > 0) {
                    comX /= totalMass;
                    comZ /= totalMass;
                    const centerX = truckDims.length / 2;
                    const centerZ = truckDims.width / 2;
                    const deviation = Math.sqrt(Math.pow(comX - centerX, 2) + Math.pow(comZ - centerZ, 2));
                    const maxDeviation = Math.sqrt(Math.pow(centerX, 2) + Math.pow(centerZ, 2));
                    const deviationRatio = deviation / maxDeviation;
                    if (deviationRatio > 0.3) stabilityScore -= (deviationRatio - 0.3) * 50;
                }
            }
            
            stabilityScore = Math.max(0, Math.min(100, stabilityScore));
            
            // ============================================================
            // OVERALL QUALITY SCORE (Composite metric)
            // Volume (30%) + Stability (30%) + Weight dist (20%) + Fragile (20%)
            // ============================================================
            let qualityScore = 0;
            
            // Volume component (0-30 points)
            qualityScore += Math.min(volumeUtil, 100) * 0.3;
            
            // Stability component (0-30 points)
            qualityScore += stabilityScore * 0.3;
            
            // Weight distribution component (0-20 points)
            let weightDistScore = 20;
            for (const box of packedBoxes) {
                if (box.weight > 25 && box.position && box.position.y > 50) {
                    weightDistScore -= 4; // Penalty for heavy items stacked high
                }
            }
            qualityScore += Math.max(weightDistScore, 0);
            
            // Fragile safety component (0-20 points)
            let fragileSafetyScore = 20;
            for (const fragileBox of packedBoxes.filter(b => b.fragile)) {
                for (const other of packedBoxes) {
                    if (other.position && fragileBox.position &&
                        other.position.y > fragileBox.position.y + fragileBox.packedDims.height - 5) {
                        const overlapX = Math.max(0, 
                            Math.min(other.position.x + other.packedDims.length, 
                                     fragileBox.position.x + fragileBox.packedDims.length) -
                            Math.max(other.position.x, fragileBox.position.x));
                        const overlapZ = Math.max(0,
                            Math.min(other.position.z + other.packedDims.width,
                                     fragileBox.position.z + fragileBox.packedDims.width) -
                            Math.max(other.position.z, fragileBox.position.z));
                        if (overlapX > 0 && overlapZ > 0) {
                            fragileSafetyScore -= 8; // Major penalty for stacking on fragile
                        }
                    }
                }
            }
            qualityScore += Math.max(fragileSafetyScore, 0);
            
            // Update utilization displays
            document.getElementById('util-volume').textContent = volumeUtil.toFixed(1) + '%';
            document.getElementById('util-floor').textContent = floorUtil.toFixed(1) + '%';
            document.getElementById('util-weight').textContent = weightUtil.toFixed(1) + '%';
            
            // Update stat-weight-pct for the grid
            const statWeightPct = document.getElementById('stat-weight-pct');
            if (statWeightPct) statWeightPct.textContent = weightUtil.toFixed(0) + '%';
            
            // Stability index display
            let stabilityRating = '';
            if (stabilityScore >= 90) stabilityRating = 'Excellent';
            else if (stabilityScore >= 75) stabilityRating = 'Good';
            else if (stabilityScore >= 50) stabilityRating = 'Fair';
            else stabilityRating = 'Poor';
            document.getElementById('util-stability').textContent = 
                packedCount > 0 ? `${Math.round(stabilityScore)}%` : '‚Äî';
            
            // Quality badge
            const badgeContainer = document.getElementById('quality-badge-container');
            if (badgeContainer && packedCount > 0) {
                let badgeClass = 'poor';
                let badgeText = 'Needs Improvement';
                if (qualityScore >= 85) { badgeClass = 'excellent'; badgeText = 'Excellent Load'; }
                else if (qualityScore >= 70) { badgeClass = 'good'; badgeText = 'Good Load'; }
                else if (qualityScore >= 50) { badgeClass = 'average'; badgeText = 'Average Load'; }
                
                badgeContainer.innerHTML = `
                    <div class="quality-badge ${badgeClass}">
                        <span>${Math.round(qualityScore)}/100</span>
                        <span>${badgeText}</span>
                    </div>
                `;
            } else if (badgeContainer) {
                badgeContainer.innerHTML = '';
            }
            
            // Update progress bars
            updateUtilBar('util-volume-bar', volumeUtil);
            updateUtilBar('util-floor-bar', floorUtil);
            updateUtilBar('util-weight-bar', weightUtil);
            updateUtilBar('util-stability-bar', stabilityScore);
        }
        
        function updateUtilBar(elementId, value) {
            const bar = document.getElementById(elementId);
            bar.style.width = Math.min(value, 100) + '%';
            
            // Remove existing classes
            bar.classList.remove('excellent', 'good', 'average', 'poor');
            
            // Add appropriate class based on value
            if (value >= 85) bar.classList.add('excellent');
            else if (value >= 70) bar.classList.add('good');
            else if (value >= 50) bar.classList.add('average');
            else bar.classList.add('poor');
        }
        
        function updateBoxList() {
            const list = document.getElementById('box-list');
            
            if (boxes.length === 0) {
                list.innerHTML = `
                    <div style="text-align: center; color: var(--text-tertiary); padding: 20px; font-size: 0.85rem;">
                        No packages added yet
                    </div>
                `;
                return;
            }
            
            list.innerHTML = boxes.map(box => {
                // Zone color based on delivery sequence
                const zoneColors = ['#30d158', '#64d2ff', '#ff9f0a', '#ff453a', '#bf5af2'];
                const zone = getDeliveryZone(box.sequence);
                const zoneColor = zoneColors[zone - 1] || zoneColors[0];
                
                const statusBadge = box.packed 
                    ? '<span class="badge badge-packed">Packed</span>'
                    : '<span class="badge badge-pending">Pending</span>';
                
                const fragileBadge = box.fragile 
                    ? '<span class="badge badge-fragile">Fragile</span>' 
                    : '';
                
                return `
                    <div class="package-item">
                        <div class="package-color" style="background-color: #${box.color.toString(16).padStart(6, '0')}; border: 2px solid ${zoneColor}"></div>
                        <div class="package-details">
                            <div class="package-title">
                                Package #${box.id} ${statusBadge} ${fragileBadge}
                            </div>
                            <div class="package-meta">
                                ${box.length}√ó${box.width}√ó${box.height} cm ‚Ä¢ ${box.weight} kg ‚Ä¢ Zone ${zone}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Get delivery zone (1-5) based on sequence
        function getDeliveryZone(sequence) {
            const maxSeq = Math.max(...boxes.map(b => b.sequence), 1);
            const zone = Math.ceil((sequence / maxSeq) * 5);
            return Math.min(Math.max(zone, 1), 5);
        }
        
        // Get zone color for visual identification
        function getZoneColor(sequence) {
            const zone = getDeliveryZone(sequence);
            const colors = ['#30d158', '#64d2ff', '#ff9f0a', '#ff453a', '#bf5af2'];
            return colors[zone - 1] || colors[0];
        }
        
        function updateStatus(message) {
            const statusEl = document.getElementById('loading-status');
            statusEl.innerHTML = `<div class="status-dot"></div>${message}`;
        }
        
        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            if (!container || !camera || !renderer) return;
            
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            // Close sidebar on orientation change for mobile
            if (window.innerWidth <= 768) {
                const sidebar = document.getElementById('sidebar');
                if (sidebar) sidebar.classList.remove('open');
            }
        }
        
        // Handle orientation change
        window.addEventListener('orientationchange', function() {
            setTimeout(onWindowResize, 100);
        });
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        window.onload = init;
    </script>
</body>
</html>